eTS Sample Exam 1 Questions.

Table of Contents

Added
Working with Java Data Types - String, String Builder
Working with Inheritance
Java Basics
Loop Constructs

Older
Basics
Random
Overloading Methods
Using Loop Constructs
Creating and Using Arrays
Working with Methods
Constructors
Working with Java Data Types - String, StringBuilder
Working with Inheritance
Using Operators and Decision Constructs
Handling Exceptions

Current on question 75
----------------------

Using Operators and Decision Constructs ----------------

Question:
What will be the result of attempting to compile and run the following code? public class public class PromotionTest{    
	public static void main(String args[]){       
		int i = 5;       
		float f = 5.5f;       
		double d = 3.8;       
		char c = 'a';       
		if (i == f) c++;       
		if (((int) (f + d)) == ((int) f + (int) d)) c += 2;       
		System.out.println(c);    
	} 
}

Answer:
In the case of i == f, value of i will be promoted to a float i.e. 5.0, and so it returns false.
(int)(f + d) => (int) (5.5 + 3.8) => (int)(9.3) => 9
(int)f+(int)d =  (int)5.5 + (int) 3.8 => 5 + 3 = 8 => this is also false
So, c is not incremented at all. Hence c remains 'a'.

Working with Java Data Types - String, String Builder --

Question:
In java, Strings are immutable. A direct implication of this is...
A. you cannot call methods like "1234".replace('1', '9'); and expect to change the original String.
B. You cannot change a String object, once it is created.
C. you can change a String object only by the means of its methods.
D. you cannot extend String class.

Answer:
A. calling such methods do not change this object. They create a new String object.
D. That's because it is final, not because it is immutable. You can have a final class whose objects are mutable.
Correct: A, B.

Working with Inheritance ------------------------

Question:
Given the following class definition:
class A{
  protected int i;
  A(int i) {    this.i = i;    }
 
}
// 1 : Insert code here
Which of the following would be a valid class that can be inserted at //1 ?
A. class B {}
B. class B extends A {}
C. class B extends A {  B()  {  System.out.println("i = " + i); }  }
D. class B { B() {} }

Answer:
B & C: Since class B does not have any constructor, the compiler will try to insert the default constructor, which will look like this: 
B(){ 
	super();  
	//Notice that it is trying to call the no args constructor of the super class, A. 
} 
Since A doesn't have any no-args constructor, the above code will fail to compile.
Notice that class A does not define a no-argument constructor. Also note that the class B does not define a constructor. Thus, class B relies on the default constructor B(). Class B's default constructor looks like this: public B() {} However, Constructors implicitly (if an explicit call to the superclass's constructor is not present) call their superclass's constructor super(). So, class B's default constructor actually looks like this:
public B(){
  super();
}
Now, since class A does not define a no-argument constructor the above code will not compile. However, class B would be correct if changed to:
class B extends A{
  B(){
    super(1); // pass it any integer
  }
  // or
  B(int number){
    super(number);
  }
}
You could also add a no-argument constructor to class A and leave class B as is.
Correct answer: A & D.

Question: What will the following program print when compiled and run?
class Game{
  public void play() throws Exception{
    System.out.println("Playing...");
  }
}

public class Soccer extends Game{
   public void play(){
      System.out.println("Playing Soccer...");      
   }
   public static void main(String[] args){
       Game g = new Soccer();
       g.play();
   }
}

Answer:
Observe that play() in Game declares Exception in its throws clause. Further, class Soccer overrides the play() method without any throws clause. This is valid because a list of no exception is a valid subset of a list of exceptions thrown by the superclass method. 
Now, even though the actual object referred to by 'g' is of class Soccer, the class of the variable g is of class Game. Therefore, at compile time, compiler assumes that g.play() might throw an exception, because Game's play method declares it, and thus expects this call to be either wrapped in a try-catch or the main method to have a throws clause for the main() method.
So the correct answer is the code will not compile.

Question:
Which of the following statements is/are true?
1. A class cannot override the super class's constructor.
2. An interface can implement multiple interfaces.

Answer:
1. Because constructors are not inherited.
2. Interface cannot "implement" anything. It can extend multiple interfaces. The following is a valid declaration : 
interface I1 extends I2, I3, I4 { }
Correct: 1.

Java Basics ---------------------------------------

Question:
The following are the complete contents of TestClass.java file. Which packages are automatically imported?  class TestClass{    public static void main(String[] args){      System.out.println("hello");    } }
1. java.lang
2. The package with no name.
Answer:
If there is no package statement in the source file, the class is assumed to be created in a default package that has no name. In this case, all the types created in this default package will be available to this class without any import statement.  However, note that this default package cannot be imported in classes that belong to any other package at all, not even with any sort of import statement. So for example, if you have a class named SomeClass in package test, you cannot access TestClass defined in the problem statement (as it is defined in the default package) at all because there is no way to import it.  As per JLS Section 7.5: A type in an unnamed package has no canonical name, so the requirement for a canonical name in every kind of import declaration implies that (a) types in an unnamed package cannot be imported, and (b) static members of types in an unnamed package cannot be imported. 
Correct: 1 & 2.

Using Loop Contstructs ----------------------------

Question:
What will be the result of attempting to compile and run the following program?
class TestClass{
   public static void main(String args[]){
      boolean b = false;
      int i = 1;
      do{
         i++ ;
      } while (b = !b);
      System.out.println( i );
   }
}

Answer:
Unlike the 'while(){}' loop, the 'do {} while()' loop executes at least once because the condition is checked after the iteration.
So the first time thru, i = 2, and b is set to true.  Then next time thru, i = 3, and the condition is set to false, so the loop ends.

Question:
What will the following code snippet print?
int count = 0, sum = 0;
do{
       if(count % 3 == 0) continue;
       sum+=count;
}
while(count++ < 11);
System.out.println(sum);

Answer:
1. The while condition uses post increment operator, which means count is first compared with 11 (and based on this comparison a decision is made whether to execute the loop again or not) and then incremented. So when count is 10, the condition 10<11 is true (that means the loop needs to be executed again) and count is incremented to 11.  
2. When count is completely divisible by 3, (i.e. when count is 0, 3, 6, 9) sum+=count; is not executed.  
Thus, the result is the summation of: 1 2 4 5 7 8 10 11

Question:
Which of the following code snippets will compile without any errors? (Assume that the statement int x = 0; exists prior to the statements below.)
1. while (false) { x=3; }
2. if (false) { x=3; }
3. do{ x = 3; } while(false);
4. for( int i = 0; i< 0; i++) x = 3;

Answer:
3. In a do- while, the block is ALWAYS executed at least once because the condition check is done after the block is executed. Unlike a while loop, where the condition is checked before the execution of the block.

while (false) { x=3; } is a compile-time error because the statement x=3; is not reachable; Similarly, for( int i = 0; false; i++) x = 3; is also a compile time error because x= 3 is unreachable.  
In if(false){ x=3; }, although the body of the condition is unreachable, this is not an error because the JLS explicitly defines this as an exception to the rule. It allows this construct to support optimizations through the conditional compilation. 
For example,  if(DEBUG){ System.out.println("beginning task 1"); }   
Here, the DEBUG variable can be set to false in the code while generating the production version of the class file, which will allow the compiler to optimize the code by removing the whole if statement entirely from the class file.
Correct: 2,3,4


**Basics** ----------------------------------------
Consider the following two classes defined in two .java files.

//in file /root/com/foo/X.java
package com.foo;
public class X{
  public static int LOGICID = 10;
  public void apply(int i){
    System.out.println("applied");
  }
}
//in file /root/com/bar/Y.java
package com.bar;
//1  <== INSERT STATEMENT(s) HERE
public class Y{
    public static void main(String[] args){
       System.out.println(X.LOGICID);
    }
}
What should be inserted at //1 so that Y.java can compile without any error?
1. import static com.foo.*;
2. import com.foo.*;

Answer:
1. Bad syntax. Package import does not use static keyword.
2. This is required because Y is accessing class X. static import of LOGICID is NOT required because Y is accessing LOGICID through X ( X.LOGICID). Had it been just System.out.println(LOGICID), only one import statement: import static com.foo.X.*; would have worked.
2 is correct.


**Random** -------------------------------------------
 
- A class cannot be declared abstract and final at the same time. 

public void saveObject(List e ){}
saveObject(null); // OK!

Since Runnable is an interface, it cannot be instantiated like this. But you can do: 
Runnable r = new Runnable(){ public void run(){ } };

int 2ndArgument = Integer.parseInt(args[2]); // LOOKOUT MUTHA FUCKA!!!

if( i = 5) { ... } // not valid because the value of the expression i = 5 is an int (5) and not a boolean.


**Overloading Methods** ------------------------------

Question:
Which of the following are true regarding overloading of a method?
A. An overloading method must have a different parameter list and same return type as that of the overloaded method.
B. If there is another method with the same name but with a different number of arguments in a class then that method can be called as overloaded.

Answer:
There is no restriction on the return type. If the parameters are different then the methods are totally different (other than the name) so their return types can be anything.  So A is wrong and B is the correct answer.



**Using Loop Constructs** ------------------------

Question:
How many times will the line marked //1 be called in the following code?
int x = 10;
do{
 x--;
 System.out.println(x);  // 1
}while(x<10);

Answer:
x keeps on decreasing by one in each iteration and every time the condition x<10 returns true. However, after x reaches -2147483648, which is its MIN_VALUE of int, it cannot decrease any further and at this time when x-- is executed, the value rolls over to 2147483647, which is Integer.MAX_VALUE. At this time, the condition x<10 fails and the loop terminates.

Question:
Which of these statements are valid when occurring by themselves?
A. do { break ; } while (true) ;
B. if (true) { break ; } (When not inside a switch block or a loop)
C. switch (1) { default : break; }
D. for ( ; true ; ) break ;

Answer:
B. Cannot have break or continue in an 'if' or 'else' block as it's not possible to break out of an if statement. But when the if statement IS placed within a labelled block or a switch statement or a loop construct, the usage of break in option 3 would be valid.
C. You can use a constant in switch(...);
Correct answers: A, C,D.



**Creating and Using Arrays** --------------------

Question:
Given the following program, which statements are true?  
// Filename: TestClass.java 
public class TestClass{    
	public static void main(String args[]){       
		A[] a, a1;       
		B[] b;       
		a = new A[10]; 
		a1  = a;       
		b =  new B[20];       
		a = b;        // 1       
		b = (B[]) a;  // 2       
		b = (B[]) a1; // 3    
	} 
} 
class A { } 
class B extends A { }
1. The program will throw a java.lang.ClassCastException at the line 2 when run.
2. The program will throw a java.lang.ClassCastException at the line 3 when run.
3. The cast at line 2 is needed.
Answer:
The line //1 will be allowed during compilation, since assignment is done from a subclass reference to a superclass reference.
The cast in line //2 is needed because a superclass reference is assigned to a subclass reference variable. And this works at runtime because the object referenced to by a is actually of an array of B.
Now, the cast at line //3 tells the compiler not to worry, that I'm a good programmer and I know what I am doing and the object referenced by the super class reference (a1) will actually be of class B at run time. So there is no compile time error. But at run time, this fails because the actual object is not an array of B but is an array of A.
So the correct answer is 2 and 3.


Question:
Identify the correct statements about ArrayList?
A. Standard JDK provides no subclasses of ArrayList.
B. You cannot store primitives in an ArrayList.
C. It allows constant time access to all its elements.
D. An ArrayList is backed by an array.

Answer:
A. It does.
Direct Known Subclasses: 
AttributeList, RoleList, RoleUnresolvedList 
B. This is true because only Objects can be stored in it.
C. This is true because it implements java.util.RandomAccess interface, which is a marker interface that signifies that you can directly access any element of this collection. This also implies that it takes the same amount of time to access any element.
D. This is true. The elements are actually stored in an array and that is why is it called an ArrayList.
(The expression "backed by an array" means that the implementation of ArrayList actually uses an array to store elements.)
ArrayList is a subclass of AbstractList.  
java.lang.Object 
-  java.util.AbstractCollection<E>    
-    java.util.AbstractList<E>      
-      java.util.ArrayList<E>  
All Implemented Interfaces: 
Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess  
Direct Known Subclasses: 
AttributeList, RoleList, RoleUnresolvedList

**Working with Methods** -------------------------

Question:
Consider the following class...
class TestClass{
   int x;
   public static void main(String[] args){
      // lot of code.
   }
}
A. By declaring x as static, main can access this.x
B. main cannot access this.x as it is declared now.
Answer:
Because main() is a static method. It does not have 'this'!
It is not possible to access x from main without making it static. Because main is a static method and only static members are accessible from static methods. There is no 'this' available in main so none of the this.x are valid.


**Constructors**

Question:
You can call only public and protected constructors of the super class from a subclass if the subclass is not in the same package because only those are inherited.

Answer:
Most of the statement is correct but remember that constructors are NEVER (whether public or otherwise) inherited. (The above statement is true for other methods though.) So, if you have a class :
class A{
     public A(int i){}
}
and another class:
class B extends A{
}
You cannot do : new B(10); because that is A's constructor and it is not inherited by B. To invoke A's constructor you have to do:
class B extends A{
     public B(int i){  super(i); }
}


**Working with Java Data Types - String, StringBuilder**
Question:
Which of these statements concerning the charAt() method of the String class are true?
A. The charAt( ) method can take a char value as an argument.
B. The charAt( ) method returns a Character object.

Answer:
A.Yes, it can because it takes an int and char will be implicitly promoted to int.
B. No, It returns char.


**Working with Inheritance** ------------------------

Question:
Which of the following statements are true?
1. Private methods cannot be overridden in subclasses.
2. A subclass can override any method in a non-final superclass.
3. An overriding method can declare that it throws a wider spectrum of checked exceptions than the method it is overriding.
4. The parameter list of an overriding method must be a subset of the parameter list of the method that it is overriding.
5. The overriding method may opt not to declare any throws clause even if the original method has a throws clause.

Answer:
1. Only methods that are inherited can be overridden and private methods are not inherited.
2. Only the methods that are not declared to be final can be overridden. Further, private methods are not inherited so they cannot be overridden either.
4. An overriding method (the method that is trying to override the base class’s method) must have the same parameters.
5. No exception (i.e. an empty set of exceptions) is a valid subset of the set of exceptions thrown by the original method so an overriding method can choose to not have any throws clause.
A method can be overridden by defining a method with the same signature(i.e. name and parameter list) and return type as the method in a superclass. The return type can also be a subclass of the orginal method's return type.
Only methods that are accessible can be overridden. A private method cannot, therefore, be overridden in subclasses, but the subclasses are allowed to define a new method with exactly the same signature. 
A final method cannot be overridden. 
An overriding method cannot exhibit behavior that contradicts the declaration of the original method. An overriding method therefore cannot return a different type (except a subtype) or throw a wider spectrum of exceptions than the original method in the superclass.
A subclass may have a static method with the same signature as a static method in the base class but it is not called overriding. It is called shadowing because the concept of polymorphism doesn't apply to static members.
Correct response: 1 and 5.

Question:
Consider the following classes:
class A {
      public int getCode(){ return 2;}
}
class AA extends A { 
  public void doStuff() { 
  } 
}
Given the following two declarations, which of the options will compile?
   A a = null;
   AA aa = null;
1. a = (AA)aa; 
2. a = new AA(); 
3. aa = new A(); 
4. aa = (AA) a; 
5. aa = a; 
6. ((AA)a).doStuff();

Answer:
4. a is declared as a reference of class A and therefore, at run time, it is possible for a to point to an object of class AA (because A is a super class of AA). Hence, the compiler will not complain. Although if a does not point to an object of class AA at run time, a ClassCastException will be thrown.
5. A cast is required because the compiler needs to be assured that at run time a will point to an object of class AA. 
6. Once you cast a to AA, you can call methods defined in AA. Of course, if a does not point to an object of class AA at runtime, a ClassCastException will be thrown.
Correct response: 1, 2, 4, and 6.


Question:
What should be inserted in the code given below at line marked //10:  
class MyClass{ }  
class MyComparable implements Comparable<MyClass>{    
	public int compareTo(  *INSERT CODE HERE*  x ) { //10          
		return 0;    
	} 
}
1. Object
2. MyClass
3. Object<MyClass>
4. Comparable<MyClass>
5. Comparable

Answer:
Since MyComparable class specifies that it implements the Comparable interface that has been typed to MyClass, it must implement compareTo method that takes a MyClass.
Had it not declared a typed Comparable in its implements clause, compareTo(Object x) would have been correct. 
The correct response is 2.


Question:
Given:
//Insert code here  

   public abstract void draw();
}
//Insert code here
   public void draw(){  System.out.println("in draw..."); }
}
Which of the following lines of code can be used to complete the above code?
A. abstract Shape {
and
public class Circle  extends Shape {
B. public abstract class Shape {
and
class Circle  extends Shape {
C. public abstract class Shape {
and
class Circle  implements Shape {
D. public interface Shape {
and
class Circle  implements Shape {

Answer:
A. The class keyword is missing from the first declaration.
C. You can only implement an interface not a class. So Circle implements shape is wrong.
D. By default all the methods of an interface are public and abstract so there is no need to explicitly specify the "abstract" keyword for the draw() method if you make Shape an interface. But it is not wrong to do so.
therefore B and D are correct.

Question:
Consider the following classes: 
class A implements Runnable{ ...} 
class B extends A implements Observer { ...} 
(Assume that Observer has no relation to Runnable.)  
and the declarations :   
A a = new A();   
B b = new B();  
Which of the following Java code fragments will compile and execute without throwing exceptions?
A. Object o = a; Runnable r = o;
B. Object o = a; Runnable r = (Runnable) o;
C. Object o = a; Observer ob = (Observer) o ;
D. Object o = b; Observer o2 = o;
E. Object o = b; Runnable r = (Runnable) b;
F. Object o = b; Runnable r4 = b;
Answer:
A. Although o refers to an object which is Runnable but the compiler doesn't know about it. You have to do: 
Runnable r = (Runnable) o; 
You can assign a subclass object reference to superclass reference without a cast but to assign a super class object reference to a subclass (or interface) reference you need an explicit cast as in option 2.
B. Here you are explicitly telling the compiler that o refers to an object that is Runnable.
C. It will compile but will fail at run time as 'a' does not refer to an object which is Observable
D. 'o' is declared as an Object. so same case as in choice A.
E. Since b is declared of a type that indirectly implements Runnable, the compiler can figure out that b will always point to an object that is assignable to a Runnable. Therefore, explicit cast is not required here. It will still work fine with the explicit cast though.
F. Since B extends A which implements Runnable, object b can be assigned to a Runnable without an explicit cast.
The correct respones is B, E and F. (See Test21.java)
Note: 
b = a; will throw a compile error: incompatible types: required B, found A.
b = (B)a; will compile but throw a runtime error: java.lang.ClassCastException

Question:
Consider the following classes :
interface I{}
class A implements I{}
class B extends A {}
class C extends B{}
And the following declarations:
A a = new A();
B b = new B(); 
Identify options that will compile and run without error.
1. a = (B)(I)b;
2. b = (B)(I) a;
3. a = (I) b;
4. I i = (C) a;

Answer:
1. class B does implement I because it extends A, which implements I. A reference of type I can be cast to any class at compile time. Since B is-a A, it can be assigned to a. 
2. This will fail at run time because a does not point to an object of class B.
3. An I is not an A. Therefore, it will not compile.
4. It will compile because a C is-a A, which is-a I, and a reference of class A can point to an object of class C. But it will fail at runtime because a does not point to an object of class C.
So answer 1 is correct.
I still don't understand why:
a = (B)(I)b;
will work, but this wont:
a = (I)b;
b is already of type B, so it doesn't need to be cast.  Also, I suppose I didn't know that you cant cast to two different types.  Never seen that before.
So check out Test20.java.  The error for 3 would be:
incompatible types: required A, found I


Question:
Which of these statements are true?
A. If a subclass does not have any declared constructors, the implicit default constructor of the subclass will have a call to super( ).
B. super(...) can only be called in the first line of the constructor but this(...) can be called from anywhere.
C. You can either call super(...) or this(...) but not both.

Answer:
Note that calling super() will not always work because if the super class has defined a constructor with arguments and has not defined a no args constructor then no args constructor will not be provided by the compiler. It is provided only to the class that does not define ANY constructor explicitly.
Correct response: A, C.

Question:
class ABCD{
   int x = 10;
   static int y = 20;
}
class MNOP extends ABCD{
   int x = 30;
   static int y = 40;
}

public class TestClass {
   public static void main(String[] args) {
     System.out.println(new MNOP().x+", "+new MNOP().y);
   }
}

Answer:
Access to static and instance fields and static methods depends on the class of reference variable and not the actual object to which the variable points to. Observe that this is opposite of what happens in the case of instance methods.  In case of instance methods the method of the actual class of the object is called.  
Therefore, in case of 
System.out.println(new MNOP().x); 
the reference is of type MNOP and so MNOP's x will be accessed.  Had it been like this:    
ABCD a = new MNOP();    
System.out.println(a.x);    
System.out.println(a.y); 
ABCD's x and y would have been accessed because a is of type ABCD even though the actual object is of type MNOP.
Output: 30, 40

Question:
Which of the given statements are correct about the following code? 
//Filename: TestClass.java 
class TestClass{    
	public static void main(String[] args){       
		A a = new A();       
		B b = new B();    
	}; 
} 
class A implements T1, T2{} 
class B extends A implements T1{} 
interface T1 { } 
interface T2 { }
A. (a instanceof T1) will return true.
B. (a instanceof T2) will return true.
C. (b instanceof T1) will return true.
D. (b instanceof T2) will return true.
E. (b instanceof A) will return false.

Answer:
D. Will return true because B extends A and 'b' is referring to an object of class B.
Since A implements both T1 and T2, 1 and 2 are correct. b instanceof A will return true as B is a subclass of A. Note that it is 'A' and not 'a'. ( b instanceof a ) will not compile.
Correct response: A,B,C,D.

Question:
Consider the following code appearing in Eagle.java
class Bird {
    private Bird(){     }
}
class Eagle extends Bird { 
    public String name;
    public Eagle(String name){
        this.name = name;
    }
    
    public static void main(String[] args) {
        System.out.println(new Eagle("Bald Eagle").name);
    }
}
What can be done to make this code compile?
A. Nothing, it will compile as it is.
B. Make Bird constructor public: public Bird() { ... }

Answer:
Since the constructor of Bird is private, the subclass cannot access it and therefore, it needs to be made public. protected or default access is also valid.
Correct choice: B.
As it is, the compile error is
Eagle.java:6: Bird() has private access in Bird
Line 6 is the public Eagle(String name){ line.



**Using Operators and Decision Constructs** ---------------------

Question:
The following method will compile and run without any problems.
public void switchTest(byte x){
   switch(x){
      case 'b':   // 1
      default :   // 2
      case -2:    // 3
      case 80:    // 4
   }
}
True of false?

Answer:
The following types can be used as a switch variable:  
byte, char, short, int, String, and enums. Note that long, float, double, and boolean are not allowed.  
All the case constants should be assignable to the switch variable type. i.e. had there been a case label of 128 ( case 128 : //some code ), it would not have compiled. Because the range of a byte is from -128 to 127 and so 128 is not assignable to 'x'.  
The integral value of 'b' is 98, which is less than 127 so Line //1 is fine.  
Note: Although it is not required for the exam to know the integral values of characters, it is good to know that all English letters (upper case as well as lower case) as well as 0-9 are below 127 and so are assignable to byte.


Question:
Given the following class definitions, the expression  
(obj instanceof A) && ! (obj instanceof C) && ! (obj instanceof D)   
correctly identifies whether the object referred to by obj was created by instantiating class B rather than classes A, C and D?    
class A {}   
class B extends A {}   
class C extends B {}   
class D extends C {} 
True or false?

Answer:
The given expression will not be able to distinguish between an object of class A and an object of class B. It will return true in both the cases. Also, The last part !(obj instanceof D) of the given expression is redundant because anything which is not instance of C cannot be an instanceof D either!  
Correct expression would be 
(obj instanceof B) && ! (obj instanceof C) 
This will return true only if obj points to an object of class B and not of A, C, or D.

Question:
What will the following code snippet print?      
Object t = new Integer(107);     
int k = (Integer) t.intValue()/9;     
System.out.println(k);
1. 11
2. 12
3. It will not compile.
4. It will throw an exception at runtime

Answer:
The compiler will complain that the method intValue() is not available in Object. This is because the . operator has more precedence than the cast operator. So you have to write it like this:     
int k = ((Integer) t).intValue()/9; 
Now, since both the operands of / are ints, it is an integer division. This means the resulting value is truncated (and not rounded). Therefore, the above statement will print 11 and not 12. 


Question:
Which of the following four constructs are valid?
1. switch(8);
2. int x = 0; switch(x){}

Answer: 
A switch statement must have a body. The body may even be empty as shown in 2.
So the correct answer is 2.

Question:
Consider that str is a variable of class java.lang.String. Which of the following lines of code may throw a NullPointerException in certain situations?  Or a tougher version of the question could be : Which of the following lines of code are not an example of robust design ?
1. if ( (str != null) | ( i == str.length() ) ) 
2. if ( (str == null) | ( i == str.length() ) ) 
3. if ( (str != null) || (i == str.length() ) )
4. if ( (str == null) || (i == str.length() ) )

Answer:
(See TestClass22)
1. (i == str.length()) will always be executed so if 'str' is null, then str.length() will throw a NullPointerException.
2. (i == str.length()) will always be executed so if 'str' is null, then str.length() will throw a NullPointerException.
3. (i == str.length()) will only be evaluated if (str != null) is false, and (str != null) will be false if 'str' is null. So it will also throw a NullPointerException.
4. (i == str.length()) will only be evaluated if (str == null) is false, and (str == null) will be false if 'str' is NOT null. So it will NEVER throw a NullPointerException.
The correct answers are 1,2 and 3.

Question:
Consider the following method...

public static void ifTest(boolean flag){
   if (flag)   //1
   if (flag)   //2
   if (flag)   //3
   System.out.println("False True");
   else        //4
   System.out.println("True False");
   else        //5
   System.out.println("True True");
   else        //6
   System.out.println("False False");
}
Which of the following statements are correct ?
1. If run with an argument of 'false', it will print 'False False'
2. If run with an argument of 'true', it will print 'True False'
3. It will never print 'True True'

Answer:
Look at it like this:
  if (flag)      //1
   {
       if (flag)       // 2
       {
            if (flag)        //3
            {
                  System.out.println("False True");
            }
            else            //4
            {
                  System.out.println("True False");
            }
       }
       else           //5
       {
             System.out.println("True True");
       }
   }
  else           //6
  {
        System.out.println("False False");
   }
Note that if and else do not cascade. They are like opening an closing brackets. So, else at //4 is associated with if at //3 and else at //5 is associated with if at //2


Question:
What will the output of the following code be?
Object o1 = new Object();
Object o2 = new Object();
System.out.println("o1 is an Object? "+(o1 instanceof o2));
ture, false, compile error, runtime error?

Answer:
This will cause a compile time error: cannot find symbol: o2.  The instanceof operator does not accept instantiated objects as the right hand side operand, only classes.  For example:
(o1 instanceof o2) Wrong.
(o1 instanceof Object) right!
- it will return true even if the right hand side is a super class.  ie:
class Animal {} class Cat extends Animal {}
Cat c = new Cat();
(c instanceof Animal) == true;

Question:
What will the following code print when run without any arguments ...
public class TestClass {
    public static int m1(int i){
        return ++i;
    }   
    public static void main(String[] args) {
        int k = m1(args.length);
        k += 3 + ++k;
        System.out.println(k);
    }
}

Answer:
When the program is run without any arguments, args gets assigned a string array of size 0. So NullPointerException or ArrayIndexOutofBoundsException are out of question. Thus, the first call becomes : int k = m1(0);
Follow through the code like this: 
1. Method m1() uses pre-increment operation. Therefore, first i is incremented and then the new value of i is returned. 
2. Thus, k gets the value of 1.
3. Expand the += operator as: k = k + 3 + ++k;
This becomes (remember that k = 1 at this point): 
k = 1 + 3 + (++k) i.e. 
k = 1 + 3 + 2; (at this point value of k is 2 because of ++k). But the value of Right Hand Side has not yet been assigned to k. 
k = 6; 6 is assigned to k thereby overwriting the value of 2.  
Therefore, the final value of k is 6.

Question:
Which of the following statements will compile without any error?
A. System.out.println("a"+'b'+63);
B. System.out.println("a"+63);
C. System.out.println('b'+new Integer(63));
D. String s = 'b'+63+"a";
E. String s = 63 + new Integer(10);

Answer:
+ is overloaded such that if any one of its two operands is a String then it will convert the other operand to a String and create a new string by concatenating the two.
Therefore, in 63+"a" and "a"+63, 63 is converted to "63" and 'b' +"a" and "a"+'b', 'b' is converted to "b".
Note that in 'b'+ 63 , 'b' is promoted to an int i.e. 98 giving 161.
A & B Since the first operand is a String all others (one by one) will be converted to String."ab" + 63 => "ab63"
C. Since the first operand of + one is of numeric type, its numeric value of 98 will be used. Integer 63 will be unboxed and added to 98. Therefore, the final value will be int 161.
D. Since the first one is numeric type so, 'b'+63 = 161, 161+"a" = 161a.
E. Since neither of the operands of + operator is a String, it will not generate a String. However, due to auto-unboxing of 10, it will generate an int value of 73.
So the correct answers are A,B,C, and D.



Question:
Consider: o1 and o2 denote two object references to two different objects of same class. Which of the following statements are true?
A. o1 == o2 will always be false.
B. Nothing can be said about o1.equals(o2) regarding what it will return based on the given information.
C. Nothing can be said about o1 == o2.

Answer:
A. The == operator compares whether the two references are pointing to the same object or not. Here, they are not, so it returns false.
B. It depends on how the class implements this method.
C. It will always return false if references are to two different objects.
Note that both equals() and hashCode() methods can be overridden by the programmer so you can't say anything about what they will return without looking at the code.
So A and B are correct.

Question:
Consider the following class :  
public class Test{    
	public static void main(String[] args){       
		if (args[0].equals("open"))          
			if (args[1].equals("someone"))             
				System.out.println("Hello!");       
		else System.out.println("Go away "+ args[1]);     
	} 
}  
Which of the following statements are true if the above program is run with the command line : java Test closed
A. It will throw ArrayIndexOutOfBoundsException at runtime.
B. It will end without exceptions and will print nothing.

Answer:
As in C and C++, the Java if statement suffers from the so-called "dangling else problem," The problem is that both the outer if statement and the inner if statement might conceivably own the else clause. In this example, one might be tempted to assume that the programmer intended the else clause to belong to the outer if statement.  
The Java language, like C and C++ and many languages before them, arbitrarily decree that an else clause belongs to the innermost if so as the first if() condition fails (args[0] not being "open") there is no else associated to execute. So, the program does nothing. The else actually is associated with the second if. So had the command line been : 
java Test open, 
it would have executed the second if and thrown ArrayIndexOutOfBoundsException. If the command line had been: 
java Test open xyz, 
it would execute the else part(which is associated with the second if) and would have printed "Go away xyz".
Personally I would write the code as below, to cure the dangling else problem.  Some people code this way.  I call it the second line format after the Eclipse IDE editor format option.  The majority of programmers and samples I see however follow the first line format shown above.  If the code is written with second line formatting as below, it can be clear which if block the else is associated with.  This would make the code run as it implies it should:
public class Test18
{    
	public static void main(String[] args)
	{       
		if (args[0].equals("open"))
		{          
			if (args[1].equals("someone"))
			{             
				System.out.println("Hello!");       
			}
		} else 
		{
			System.out.println("Go away "+ args[1]);     
		}
	} 
}  
When the above code is run, open Tim will have no output, and open someone will say hello.
But actually, when run as shown in the question, the program requires a second argument to work, otherwise there is an error.  If we revert to the original else glued to the second if, then open Tim will say go away, and open someone will say hello.  So maybe that IS what was intended.  But we need to move on...


**Handling Exceptions** -----------------------------------------

Question:
What is the result of compiling and running this code?
class MyException extends Throwable{}
class MyException1 extends MyException{}
class MyException2 extends MyException{}
class MyException3 extends MyException2{}
public class ExceptionTest{
   void myMethod() throws MyException{
      throw new MyException3();
   }
   public static void main(String[] args){
      ExceptionTest et = new ExceptionTest();
      try{
         et.myMethod();
      }
      catch(MyException me){
         System.out.println("MyException thrown");
      }
      catch(MyException3 me3){
         System.out.println("MyException3 thrown");
      }
      finally{
         System.out.println(" Done");
      }
   }
}
Which exception is thrown?

Answer:
You can have multiple catch blocks to catch different kinds of exceptions, including exceptions that are subclasses of other exceptions. However, the catch clause for more specific exceptions (i.e. a "SubClassException") should come before the catch clause for more general exceptions ( i.e. a "SuperClassException"). Failure to do so results in a compiler error as the more specific exception is unreachable.

In this case, catch for MyException3 cannot follow catch for MyException because if MyException3 is thrown, it will be caught by the catch clause for MyException. And so, there is no way the catch clause for MyException3 can ever execute. And so it becomes an "unreachable" statement.
Correct answer: It fails to compile.


Question:
Which statements regarding the following code are correct ?
class Base{
   void method1() throws java.io.IOException, NullPointerException{
      someMethod("arguments");
      // some I/O operations
   }
   int someMethod(String str){
      if(str == null) throw new NullPointerException();
      else return str.length();
   }
}
public class NewBase extends Base{
      void method1(){
           someMethod("args");
      }
}
1. method1 in class NewBase does not need to specify any exceptions.
2. The code will not compile because RuntimeExceptions cannot be given in throws clause.
3. method1 in class NewBase must at least give IOException in its throws clause.
4. method1 in class NewBase must at least give NullpointerException in its throws clause.
5. There is no problem with the code.

Answer:
Overriding method only needs to specify a subset of the list of exception classes the overridden method can throw. A set of no classes is a valid subset of that list.
Remember that  NullPointerException is a subclass of RuntimeException, while IOException is a subclass of Exception.
2. Any Exception can be specified in the throws clause.
4. This is not needed because NullPointerException is a RuntimeException.
Correct answer: 1 & 5.

Question:
What will be the result of compiling and running the following program ?
class NewException extends Exception {}
class AnotherException extends Exception {}
public class ExceptionTest{
    public static void main(String[] args) throws Exception{
        try{
            m2();
        }
        finally{
            m3();
        }
        catch (NewException e){}
    }
    public static void m2() throws NewException { throw new NewException(); }
    public static void m3() throws AnotherException{ throw new AnotherException(); }
}
A. It will compile but will throw AnotherException when run.
B. It will not compile.

Answer:
The correct answer is B because a catch block cannot follow a finally block!
The error: 'catch' without 'try'.
Syntax of try/catch/finally is: 
try{ } 
catch(Exception1 e) {... } 
catch(Exception2 e) {... } ... 
catch(ExceptionN e) {... } 
finally { ...  }
With a try, either a catch and or finally or both can occur. A try MUST be followed by at least one catch or finally. (Unless it is a try with resources statement, which is not in scope for this exam.) 
In Java 7, you can collapse the catch blocks into a single one: 
try { ... }
catch (SQLException | IOException | RuntimeException e) {        
	// In this block, the class of the actual exception object will be whatever 
	// exception is thrown at runtime.   
	// But the class of the reference e will be the closest common super 
	// of all the exceptions in the catch block.   
	// In this case, it will be java.lang.Exception 
	// because that is the most specific class that is a super class
	// for all the three exceptions.   
	e.printStackTrace(); 
}

Question:
Consider the following code...  
class MyException extends Exception {}  
public class TestClass{      
	public void myMethod() throws XXXX{          
		throw new MyException();      
	} 
}  
What can replace XXXX?
A. MyException
B. Exception
C. Throwable
D. RuntimeException

Answer:
B. Because Exception is a superclass of MyException.
A throws clause is necessary because MyException is a checked exception. Any exception that extends java.lang.Exception but is not a subclass of java.lang.RuntimeException is a checked exception.
C. Because Throwable is a super class of Exception.
Why: You can use Throwable as well as Exception as both of them are super classes of MyException. RuntimeException (and its subclasses such as NullPointerException and ArrayIndexOutOfBoundsException) is not a checked exception. So it cannot cover for MyException which is a checked exception. You cannot use Error as well because it is not in the hierarchy of MyException, which is: 
Object <- Throwable <- Exception <- MyException.
Correct Answer: A, B, C but not D.

Question:
Identify the exceptions that are usually thrown by the JVM and the exceptions usually thrown by an application.
A.
	    JVM : IllegalStateException, IllegalArgumentException
Application :  ClassCastException, NullPointerException, SecurityException
B.
		JVM : ClassCastException, NullPointerException, SecurityException
Application :  IllegalStateException, IllegalArgumentException

Answer:
Note: The terminology "thrown by the JVM" and "thrown programatically or by the application" is not precise but is used by popular books. If it helps, you can think of the exception categories as "thrown implicitly" and "thrown explicitly". An exception that is thrown even when there is no throw statement, is said to be thrown implicitly. For example, calling a method on null will cause a NullPointerException to be thrown automatically, even though there is no throw statement. On the other hand, a code may throw an exception explicitly by using the throw statement. For example, a method code might check an argument for validity and if it finds the argument inappropriate, it may throw an exception by executing throw new IllegalArgumentException();.  
A quick way to determine who should throw an exception is to see if the exception extends java.lang.Error. Errors are always thrown only by the JVM.  
Generally, RuntimeExceptions are also thrown by the JVM. However, it is ok for an application code to throw a RuntimeException if it makes sense for the application to throw a RuntimeException in a given situation.  
The correct answer is B.
Both of those categories: thrown by the JVM and programatically are unchecked runtime exceptions.  This is the first we are hearing about a distinction between these types of exceptions.
thrown by the JVM: impicitly, even when there is no throw statement.
thrown programatically: explicitly using a throw statement.
It's not really a fair question.  It's not discussed in the Java tutorials.
And where is a complete list of these so call programatically thrown exceptions?




















**Unsorted** -----------------------------------------------



Question:
Given the following class definitions :
interface MyIface{};
class A {};
class B extends A implements MyIface{};
class C implements MyIface{};
and the following object instantiations:
  A a = new A();
  B b = new B();
  C c = new C();
Which of the following assignments are legal at compile time?

Answer:
c = (C) b; // Compiler can see that in no case can an object referred to by b can be of class c. So it is a compile time error.
MyIface i = c; // Compiler can see that in no case can an object referred to by b can be of class c. So it is a compile time error.

Question:
What will the following code print?
        int[] scores1 = { 1, 2, 3, 4, 5, 6};
        int[] scores2 = { 0, 0, 0, 0, 0, 0};
        System.arraycopy(scores2, 2, scores1, 3, 2);
        for(int i :  scores2) System.out.print(i);
Answer:
Source is scores2 and destination is scores1. So scores1 will become 1 2 3 0 0 6. However, you are printing scores2, which is still {0, 0, 0, 0, 0, 0}.

System.arraycopy(scores2, 2, scores1, 3, 2);
scores2 = src
2       = srcPos
scores1 = dest
3		= destPos
2		= length
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
- The number of components copied is equal to the length argument. The components at positions srcPos through srcPos+length-1 in the source array are copied into positions destPos through destPos+length-1, respectively, of the destination array. 
- If the src and dest arguments refer to the same array object, then the copying is performed as if the components at positions srcPos through srcPos+length-1 were first copied to a temporary array with length components and then the contents of the temporary array were copied into positions destPos through destPos+length-1 of the destination array.  
- If dest is null, then a NullPointerException is thrown.  
- If src is null, then a NullPointerException is thrown and the destination array is not modified.
- ArrayStoreException is thrown and the destination is not modified if any of the following is true:
	- The src or dest arguments refers to an object that is not an array. 
	- The src argument and dest argument refer to arrays whose component types are different primitive types. 
	- The src and dest arguments refers to different types, such as an array with a primitive component type and an array with a reference component type.
- IndexOutOfBoundsException is thrown and the destination is not modified if any of the following is true:
	- The srcPos, destPos or length argument is negative. 
	- srcPos+length is greater than src.length, the length of the source array. destPos+length is greater than dest.length, the length of the destination array.
- ArrayStoreException is thrown if any actual component of the source array from position srcPos through srcPos+length-1 cannot be converted to the component type of the destination array by assignment conversion. 
In this case, let k be the smallest nonnegative integer less than length such that src[srcPos+k] cannot be converted to the component type of the destination array; when the exception is thrown, source array components from positions srcPos through srcPos+k-1 will already have been copied to destination array positions destPos through destPos+k-1 and no other positions of the destination array will have been modified. (Because of the restrictions already itemized, this paragraph effectively applies only to the situation where both arrays have component types that are reference types.)

Question:
boolean b = 1; 

Answer:
Compile error: incomatible types.

Question:
Given:
	StringBuilder b1 = new StringBuilder("snorkler");
	StringBuilder b1 = new StringBuilder("yoodler");
b1.append(b2.substring(2,5).toUpperCase());
b2.insert(3,b1.append("a"));
b1.replace(3,4,b2.substring(4)).append(b2.append(false));

Answer:
- You need to understand how append, insert, delete, and substring methods of StringBuilder/StringBuffer work. Please go through JavaDoc API for these methods. This is very important for the exam. Observe that substring() does not modify the object it is invoked on but append, insert and delete do.
- In the exam, you will find questions that use such quirky syntax, where multiple calls are chained together. For example: 
sb.append("a").append("asdf").insert(2, "asdf"). 
- Make yourself familiar with this technique. If in doubt, just break it down into multiple calls. For example, the aforementioned statement can be thought of as:  
sb.append("a"); 
sb.append("asdf"); 
sb.insert(2, "asdf")  
- Note that the method substring() in StringBuilder/StringBuffer returns a String (and not a reference to itself, unlike append, insert, and delete). So another StringBuilder method cannot be chained to it. For example, the following is not valid: 
sb.append("a").substring(0, 4).insert(2, "asdf");  
The error would be: cannot find symbol: method inster(int,String) location: class String.
- The following is valid though:  
String str = sb.append("a").insert(2, "asdf").substring(0, 4);

Question:
Consider the following method...  
public int setVar(int a, int b, float c) { ...}  
Which of the following methods correctly overload the above method?
A. public int setVar(int a, float b, int c){   return (int)(a + b + c); }
B. public int setVar(int a, float b, int c){   return this(a, c, b); }
C. public float setVar(int a){   return a; }

Answer:
B. this( ... ) can only be called in a constructor and that too as a first statement.
method is said to be overloaded when the other method's name is same and parameters ( either the number or their order) are different. Option 2 is not valid Because of the line: return this(a, c, b); This is the syntax of calling a constructor and not a method. It should have been: return this.setVar(a, c, b);

Question:
What will the following program print? 
class LoopTest{
    public static void main(String args[]) {
        int counter = 0;
        outer:
        for (int i = 0; i < 3; i++) {
            middle:
            for (int j = 0; j < 3; j++) {
                inner:
                for (int k = 0; k < 3; k++) {
                    if (k - j > 0) {
                        break middle;
                    }
                    counter++;
                }
            }
        }
        System.out.println(counter);
    }
}

Answer:
To understand how this loop works let us put some extra print statements in the innermost loop:
System.out.println("i="+i+" j="+j+" k="+k);
if(k-j>0){
     System.out.println("breaking middle "+j);
     break middle;
}
counter++;
This is what it prints:
i=0 j=0 k=0
i=0 j=0 k=1
breaking middle 0
i=1 j=0 k=0
i=1 j=0 k=1
breaking middle 0
i=2 j=0 k=0
i=2 j=0 k=1
breaking middle 0
3
The key is that the middle loop is broken as soon as k-j becomes > 0. This happens on every second iteration of inner loop when k is 1 and j is 0. Now, when middle is broken inner cannot continue. So the next iteration of outer starts.

Question:
Consider the following two classes (in the same package but defined in different source files):
public class Square {
    double side = 0;
    double area;
    public Square(double length){        this.side = length;    }
    public double getSide() {  return side;    }
    public void setSide(double side) {  this.side = side;   }
    double getArea() {   return area;   }
}
public class TestClass {
    public static void main(String[] args) throws Exception {
        Square sq = new Square(10.0);
        sq.area = sq.getSide()*sq.getSide();
        System.out.println(sq.getArea());
    }
}
You are assigned the task of refactoring the Square class to make it better in terms of encapsulation. What changes will you make to this class?
A. Make side and area fields private.
B. Make the side field private and remove the area field.
C. Change getArea method to:
D. Add a setArea() method.

Answer:
A. There is no need to keep the area field because that would amount to duplicating the data. If you change side, the value of area will become obsolete.
D. This is not required because area is calculated using the side. So if you allow other classes to set the area, it could make side and area inconsistent with each other.
There can be multiple ways to accomplish this. The exam asks you questions on the similar pattern.
The key is that your data variable should be private and the functionality that is to be exposed outside should be public. Further, your setter methods should be coded such that they don't leave the data members inconsistent with each other.
Therefore B and C are the correct answers.




