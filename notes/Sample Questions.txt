Sample Questions

Consider the following code snippet:
    arrayOfInts[j] > arrayOfInts[j+1]
Question: What operators does the code contain?
Answer: >, +

Consider the following code snippet:
int i = 10;
int n = i++%5;
    Question: What are the values of i and n after the code is executed?
    Answer: i is 11, and n is 0.
    Question: What are the final values of i and n if instead of using the postfix increment operator (i++), you use the prefix version (++i))?
    Answer: i is 11, and n is 1.

Questions and Exercises: Inheritance
1.a and c incorrect.  How do you hide an inherited method?  It's considered a bad programming practice, but the table in Overriding and Hiding Methods section shows the effect of declaring a method with the same signature as a method in the superclass.
http://docs.oracle.com/javase/tutorial/java/IandI/override.html

- What Integer method would you use to convert a string expressed in base 5 into the equivalent int? For example, how would you convert the string "230" into the integer value 65? Show the code you would use to accomplish this task.
String base5String = "230";
int result = Integer.valueOf(base5String, 5);
static Integer	valueOf(String s, int radix): Returns an Integer object holding the value extracted from the specified String when parsed with the radix given by the second argument.


Question: What Double method can you use to detect whether a floating-point number has the special value Not a Number (NaN)?
Answer: isNaN()

NaN	
	Double d1 = new Double(-1.0/0.0);
	Double d2 = new Double(0.0/0.0);
     // returns true if this Double value is a Not-a-Number (NaN) 
     System.out.println(d1 + " = " + d1.isNaN()); // false
     System.out.println(d2 + " = " + d2.isNaN()); // true

###gocertify###
1. E
int []a = {1,2,3,4,5,6};
ini i = a.length -1;
while(i>=0)
{System.out.println(a[i]);i--}
Result 654321
a len is 6. go from index 5 to 0

3. Must extend an abstract class
4. An interface can't extend a class
An interface can extend multiple interfaces
5. Arrays are objects, so
int a[] = {1,2,3,4}
print(a instanceof Object) prints true.
-6. Indexing of array elemnts begins with zero, 43 = o53 (octal)
7. anonymous arrays.  assigned two one dimensional int arrays to the two dinmensiaonal array a.  So the code compiles and poroduces 2.
int a[][] = new int[3][];
a[1]=new int[]{1,2,3};
a[2]=new int[]{4,5};
print(a[1][1]); = 2

11. wrong pass by reference nightmare
-12
class Base
{
	int i = 99;
	public void amethod()
	{
		System.out.println("Base.amethod");
	}
	Base()
	{
		amethod();
	}
}
public class Derived extends Base
{
	int i = -1;
	public static void main(String argv[])
	{
		Base b = new Derived();
		System.out.println(b.i);
		b.amethod();
	}
	public void amethod()
	{
		System.out.println("Derived.amethod()");
	}
}
Output: 
Derived.amethod()
99
Derived.amethod()
It creates an instance of the Derived class but assigns it to a reference of the Base class.  In this situation a reference to any of the fields such as i will refer to the value in the Base class, but a call to a method will refer to the method in the class type rather than its reference handle.  But note that if the amethod() was not present in the base class, then compilation error would be reported at compile time.  When the compiler sees the statement like b.amethod(), it checks if the method is present in the Base class or not.  Only at the run time it decides to call the method from the derived class.
13. 
String s = "Java";
s.concat(" SE 6");
s.replace('6','7');
print(s) // Java (the two calls are abandoned instantly)
14.
line 3, two more objects created, 'SE 6', and 'Java SE 6'
line 5 'java'
3. String s = "Java"; 1
4. s.concat(" SE 6"); 2,3
5. s.toLowerCase();   4
15

Test http://www.gocertify.com/quizzes/java/scjp1/

2. Any string other than 'true' of 'false' as a Boolean constructor will result in a value of false;  Note case does not matter.
boolean a = new Boolean("tRuE"); will allocate a Boolean object representing true.

4. 
int a = 5;
print("Value is - "+((a < 5) ? 9.9 : 9));
The result of a ternary operator must be determined at compile time, and here the type chosen using the rules of promotion for binary operands is double.  Since the result is a double the output value is printed in a floating point.  The choice of which value to be printed is made on the basis of the result of the comparison "a < 5" which results in false, hence the variable "a" takes the second of the two possible values, which is 9, but because the result type is promoted to double the output value is actually written as 9.0 rather than the more obvious 9.
5. a,c,d,e (Ouch, no d! and b is ok too..)
public class Outer {
	public int a = 1;
	privte int b = 2;
	public void method(final int c)
	{
		int d = 3;
		class inner
		{
			private void iMethod(int e)
			{
				// which variables may be referenced here?
			}
		}
	}
}
a, b, c and e are correct. Since inner is not a static inner class, it has a reference to an enclosing object and all the variables of that object are accessible. Therefore A and B are correct even if b is private. Variables in the enclosing method are only accessible when they are marked as final, hence c is accessible but not d. E is obviously correct as it is a parameter to the method containing line 12 itself.  d is not final so not visible.

X6. - an overriding method can allow more, but not less, access than the overridden method. Order: public, protected, (no modifier), private

X16.
class Parent
{
	private void method1(){System.out.println("Parent1");}
	public void method2(){System.out.println("Parent2"); method1();}
}
class Child extends Parent
{
	public void method1()
	{System.out.println("Child1");}
	 public static void main(String args[])
	 {Parent p = new Child();p.method2();}
}
Output: 
Parent2
Parent1
If method1 in parent were not private, the output would be:
Parent2
Child1


Javaprepare Mock exam 1 for SCJP 6

x2.c,g - bcf
x5. 0005 0x05
x6. c,f,g,h - bcfg
x9."amp" - am
x10.A - ac 
C. The method definitions inside interfaces are public and abstract. They cannot be private or protected.

x11.F 14 ^ 23 = ?
x13.private - protected
x14.c,d - a,c
x16.b - c
x21.b,d,e - bce
x25.e - a
x27.e - d
x*32.a,c - bd
?33.c - bc
-34.c collections
x35.a " - c
x37.c - f
-?38.the return type of method round(double d) defined in Math class
long or float
x42.ArrayList
x46.String of hex value. - int
x47.b - d
29 out of 48 is 60%.  Not good enough.  Need to get at least 80.

PDF Questions:

Test you knowledge:
Chapter 1: Getting Started with Java p.37 (2/2)

Chapter 2: Java Data Types and Their Usage p.76 (4/6)
X1.a x c.cannot access an instance variable from a static method.
X2.a. x c,e 
float f=3.1415; float f = 3.14f;
byte b=257; byte -128 to 127 only.
OX4.a,d x a,b,d: No!  a and d only are right.  Mistake in question!

Chapter 3: Decision Constructs p.114 (5/5!)

Chapter 4: Using Arrays and Collections p.151 (1/3)
X1.a,b,c,d
Which of the following statements will compile without an error?
a. int arr[];
b. int arr[5];
c. int arr[5] = {1,2,3,4,5};
d. int arr[] = {1,2,3,4,5};
a and d The number of elements in an array declaration is not used in
the declaration. However, we can use the following:
int arr[] = new int[5];
O2.b
X3.a x 
Given the following code, which of the following statements can be used to
determine if cat can be found in the list?
ArrayList<String> list = new ArrayList<>();
list.add("dog");
list.add("cat");
list.add("frog");
a. list.contains("cat")
b. list.hasObject("cat") x
c. list.indexOf("cat")
d. list.indexOf(1)       x
a and c The contains method will return true if the object is found
and indexOf takes an object reference and returns the index
of the object if found, otherwise it returns a -1. The indexOf
method does not take an integer argument and the hasObject
method does not exist.

Chapter 5: Looping Constructs p.183 (4/5)
X1.a,c
p.179 pitfalls
Given the following declarations, which of the following statement will
compile?
int i = 5;
int j = 10;
a. while(i < j) {}
b. while(i) {}
c. while(i = 5) {}  thought it was i == 5!
d. while((i = 12)!=5) {}  // (12 != 5)
a and d The other options will not work because the expression does
not evaluate to a Boolean value.
OX2.b
Given the following declaration of an array, which statement will display
each element of the array?
int arr[] = {1,2,3,4,5};
a. for(int n : arr[]) { System.out.println(n); }
b. for(int n : arr) { System.out.println(n); }
c. for(int n=1; n < 6; n++) { System.out.println(arr[n]);
}
d. for(int n=1; n <= 5; n++) { System.out.println(arr[n]);
}
b,c,d are correct.
No, they aren't!  only b is correct. c  misses the first element, and d causes an array index out of bounds exception!

Chapter 6: Classes, Constructors, and Methods p.216 (3/7) -------
X1.b
Which of the following declares a method that takes a float and an integer and returns an array of integers?
a. public int[] someMethod(int i, float f)
{ return new int[5];}
b. public int[] someMethod(int i, float f)
{ return new int[];}
c. public int[] someMethod(int i, float f)
{ return new int[i];}
d. public int []someMethod(int i, float f)
{ return new int[5];}
a, c, and d Option b fails to initialize the array properly.


X3.b
Which of the following statements about overloaded methods are true?
a. Static methods cannot be overloaded.
b. The return value is not considered when overloading a method.
c. Private methods cannot be overloaded.
d. An overloaded method cannot throw exceptions.
a The return value is not considered when overloading a method.
(isnt that what our answer said?)
Yes, we did get this right.  b is the correct answer.

X4.a
Given the following code, which of the following statements are true?
public class SomeClass {
public SomeClass(int i, float f) { }
public SomeClass(float f, int i) { }
public SomeClass(float f) { }
public void SomeClass() { }}
a. error will occur cause void cannot be used with a constructor.
b. error will occur cause the first two constructors are not unique.
c. The class does not have a default constructor.
d. No syntax errors will be generated.
c and d The last line is a method that happens to have the same name as the constructor. As there are constructors defined but no
default constructor, the class has no default constructor.

X5.d
Which of the following keywords cannot be used when declaring a class?
a. public  OK
b. private OK
c. protected x
d. package   x
a and b Only the private and public keywords can be used when
declaring a class and the private keyword can only be used
with inner classes.

X6.a,c,d
Assuming that the following classes are in the same package, which
statements are true?
class SomeClass 
{
	void method1() { }
	public void method2( { }
	private void method3( { }
	protected void method4() { }}
	class demo 
	{
		public void someMethod(String[] parameters) 
		{
			SomeClass sc = new SomeClass();
			sc.method1();
			sc.method2();
			sc.method3(); only protected methods are not visible.
			sc.method41();}}
a. sc.method1() will generate a syntax error.
b. sc.method2() will generate a s0yntax error.
c. sc.method3() will generate a syntax error.
d. sc.method4() will generate a syntax error.
e. No syntax errors will be generated.
c As the classes are in the same package and all of the methods
are visible except for the private method.

Chapter 7: Inheritance & Polymorphism (1/6) ---------p.246
X1.c,d
Which set of statements result in ClassB and ClassC being derived
from ClassA?
a. class ClassB extends ClassA {}
b. class ClassB extends ClassC {}
c. class ClassA extends ClassB {}
d. class ClassC extends ClassB {}
e. No combination will work
a, d (second time around answer is correct!)
Answer: a and d This results in ClassC being the "grandchild" of ClassA.

X2.a,b,c?
Which of the following must be true for a method to support polymorphism?
a. The method must override a base class method
b. The method must overload a base class method
c. The method's class must extend a base class that has the
overridden method
d. The method must execute against a base class reference variable
a,c (second time around also wrong)
Answer: a and d.  Overloading only occurs within the same class. It is not necessary to have a base class. A common implemented interface will also work for polymorphic behavior.

X3.c
What method is used to determine the type of an object?
a. isType
b. typeOf
c. instanceof
d. instanceOf
a
Answer: d The other methods do not exist.
We beg to differ.  instanceof is an operator.  The method would be getClass and then use instancof?  Pretty sure they mean c., which then makes the question's use of the word 'method' wrong.

X4.a,b,c
Which of the following are valid casts?
a. num1 = num2;
b. num1 = (int)num2;
c. num1 = (float)num2;
d. num1(int) = num2;
a,b,c
Answer: b.  The others will generate syntax errors.

X5.d
Given the following class definitions:
public class ClassA 
{
	public ClassA() 
	{
		System.out.println("ClassA constructor");
	}
	public void someMethod() 
	{
		System.out.println("ClassA someMethod");
	}
}
class ClassB extends ClassA 
{
	public ClassB() 
	{
		System.out.println("ClassB constructor");
	}
	public void someMethod() 
	{
		// comment
		System.out.println("ClassB someMethod");
	}
	public static void main(String args[]) 
	{
		ClassB b = new ClassB();
		b.someMethod();
	}
}

What statement is needed at the comment line to generate the
following output:
ClassA constructor
ClassB constructor
ClassA someMethod
ClassB someMethod
a. super();
b. super().someMethod;
c. super.someMethod();
d. someMethod();
e. None of the above
c (second time lucky!)
c The first answer is used only as the first statement of a
constructor. The second answer generates a syntax error. The
fourth option results in unbounded recursion.

Chapter 8: Handling Exceptions in an Application p.275 (3/5)
x1.a,c,d
1. Which of the following implement checked exceptions?
a. Class A extends RuntimeException
b. Class A extends Throwable
c. Class A extends Exception
d. Class A extends IOException
d (second time wrong.  This time we ignored the implment part of the question)
Answer: c and d Checked exceptions are those classes that extend the Exception class but not the RuntimeException class.

X5.b,d
What exceptions may the following code generate at runtime?
String s;
int i = 5;
try{
	i = i/0;
	s += "next";
}
a. ArithmeticException
b. DivisionByZeroException
c. FileNotFoundException
d. NullPointerException
b,d
Answer: a and d DivisionByZeroException does not exist. No file
operations are performed here.

(p.297 answers)

====================

Chapter 1: Getting Started with Java p.37 (2/2)
Chapter 2: Java Data Types and Their Usage p.76 (4/6)
Chapter 3: Decision Constructs p.114 (5/5!)
Chapter 4: Using Arrays and Collections p.151 (1/3)
Chapter 5: Looping Constructs p.183 (4/5)
Chapter 6: Classes, Constructors, and Methods p.216 (3/7)
Chapter 7: Inheritance & Polymorphism (1/6) 
Chapter 8: Handling Exceptions in an Application p.275 (3/5)
23 out of 39 is 58%.  We need to score above 70% to pass, and advice said we should be scoring above 80% on mock exams before attempting the test.  
So no time to waste.



EPractize Test Product ---------

BufferedReader reader = null;      
try {         
		URL url = new URL("http://www.epractizelabs.com/serverdate.html");         
		reader = new BufferedReader(new InputStreamReader(url.openStream()));         
		String line = reader.readLine();         
		SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");         
		Date date = format.parse(line);     
	  } catch (MalformedURLException exception) 
	  {          // handle wrong URL     
	  } catch (IOException exception) 
	  {          // handle I/O errors     
	  } catch (ParseException exception) 
	  {          // handle date parse problems.     
	  } finally 
	  {          
		if (reader != null) 
		{             
			try 
			{                 
				reader.close();             
			} catch (IOException ex) 
			{                 
				ex.printStackTrace();             
			}          
		}     
	}

Question : Which of the following Java SE 7 code replaces above code?

Select one. 
Choice A: 
try {     
	BufferedReader reader = new BufferedReader(new InputStreamReader( new URL("http://www.epractizelabs.com/serverdate.html").openStream()));     
	String line = reader.readLine();     
	SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");    
	Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Choice B: (Chosen)
try (BufferedReader reader = new BufferedReader(new InputStreamReader(new URL                                                            ("http://www.epractizelabs.com/serverdate.html").openStream()))) {     String line = reader.readLine();     SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");     Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Choice C: 
try (@BufferedReader reader) {     reader = new BufferedReader(new InputStreamReader( new URL                                    ("http://www.epractizelabs.com/serverdate.html").openStream()));     String line = reader.readLine();     SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");     Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Pre Measurement  Date : 01/04/2014 
Passing score : 77%   Your score : 75%    Test status : Fail
Total No. of question(s): 16                                                   
Correct answered question(s) : 12

Objective Score
Java Basics 50%
Working With Java Data Types 33%
Using Operators and Decision Constructs 100%
Creating and Using Arrays 0%
Using Loop Constructs 100%
Working with Methods and Encapsulation 100%
Working with Inheritance 100%
Handling Exceptions 100%

Which are List objects?
- ArrayList
- LinkedList
- Vector
- Stack

What is true about local inner classes?
- It can access only final variables.

A static method can only be hidden by another static method.  A static variable may be hidden by an instance variable.

The combination of 'abstract' and 'synchronized' modifiers are not allowed.

According to the JavaBean naming standards, if the boolean property is named 'x', the accessor method is of the form boolean isX() and the mutator method is of the form void setX(boolean newValue)

variable arguments allows a method to be called with ZERO or more arguments.

A variable from an interface is by default final so cannot be changed in a subclass.
- Interfaces only describe behaviour, not state.
- they're only to be used as constants. Hence static and final. 

Class members cannot use the this keywords as there is no this to refer to.

False: Member inner classes are the static class.

Finalize will always run before an object is garbage collected.

Questions: When using the writeObject method to store (serialize) the state of an object, how can you protect sensitive data from being acessed in the stored object?
Answer: declare the sensitive fields as private transient.

Question: Which of the following keywords is used when a constructor calls an overload constructor in the same class.
Answer: this

Integer n1 = new Integer(0);
Byte n2 = new Byte((byte)0);
System.out.println(n1.equals(n2)); false!!!

- abstract classes cannot be instantiated

- super() must be the first statement in a subclass contructor.

quote(String s) returns a literal pattern string for the specified String.  This method produces a String that can be used to create a Pattern that would match the String s as if it were a literal pattern.  Meta characters or escape sequences in the input sequence will be given no special meaning.

- Number is the super class for many wrapper classes, but not Boolean and Character

- Nested (inner) classes can be declared abstract, final, private, public, or protected to restrict access to the class.

class Bank
{
	String bankName;
	public String getBranchName()
	{
		return bankName;
	}
}
public class BankBranch extends Bank
{
	public static void main(String[] argv) {}
	public String getBranchName() throws Exception 
	{
		return bankName;
	}
}
Does not compile: getBranchName() cannot override the superclass method.  The overridden method does not throw an exception.  (But it could if it were a runtime exception, right?  Or is that only checked exceptions?)

- The split() and matches() methods are present in both String and Pattern class.

- checked exceptions represent invalid conditions in areas outside the immediate control of the program.

String str = "10";
int a = new Integer(10);
boolean b = str==a;
The comparison is not legal, as only the + operator performs the implicit conversion to a String object.
ie: b = str==a+""

- if the unary operators + and - are applied to byte, char or short the types are automatically promoted to an int.

How does this code compile?
```
Number Float = 99.455f;
```
Answer, Float is not a reserved word.  'float' is.

```
boolean b = false;
boolean c = true;
if (b = c) ... true
```
The if evaluates to true because the assigment statement also has a value equal to the value being assinged.
if (b == c) ... false

Integer a = 123;
float b = 123f;
boolean c = false;
if (c|a==b) ... true!
- The a==b will be evaluated first.

boolean b=str==a; will not compile.
Incomparable types: String and Integer 

String num = "0";
num = null;
if (num instanceof Object) ... false!
- null compared with a string is not equal.

Integer number = 145; // autoboxing is ok.

Vector<String> set = new Vector<String>();
String[] arr = set.toArray();
- The toArray() method returns Object[], so to compile, the set must be cast to String.  You can fix it like this:
String[] arr = (String [])set.toArray();


The size of the array cannot be specified in the following examples:
		int i[] = new int[2] {1,2};
		int j[4] = {1,2,3,4};
The size is given implicitly by the initialization code (instance), never in the declaration of an array (reference).

void aMethod(Object ob) { //1 }
void aMethod(Float ob) {  //2 }
...
test.aMethod(0.0);  // autoboxed to Double object.

- An overriding method must not throw any checked exceptions that were not declared in the original method.

- constructors are not inherited

A a = new A();
B b = new B(); // A extends B

b=a 	x
b=(A)a; x
a=b;
a=(A)b;
a=(B)b;


class Test3
{
	public String toString() {
		return "Test3";
	}

	public static void main(String[] args) {
		Set<Test3> s = new TreeSet<Test3>();
		s.add(new Test3()); // Test3 cannot be cast to Comparable.
		s.add(new Test3());
		s.add(new Test3());
		for (Test3 out: s)
			System.out.println(out);
	}
	/**
	Either Test3 has to implement Comparable, or you need to provide a comparator when creating the TreeSet.
	 */
}
To fix this:
class Test3 implements Comparable {
 	@Override
    public int compareTo(Test3 test)
    { /* Custom test */ }

Writer w = new BufferedWriter(new FileWriter());
This will cause an IOException.
- If the named file exists but is a directory rather than a file, an IOException will be thrown.
Writer w = new BufferedWriter(new FileWriter("name.txt"));
- If the file doesnt exist it will be created.


When you call System.exit() inside a finally block, the system will exit.

Mock Exam 2

int num = -50;
System.out.println(num % 25.0)
output -0.0
We suppose that any expression containing a negative will give a negative answer, as well as follow the rules of promotion.

- j2ee-struts is not a valid identifier because it has a SLASH!!!

RegEx question:
java Test x7+y8+z9=4P [4789][+-=]
Test class main has this expression:
System.out.println((args[0].split(args[1])).length);
[abc][vz] Set definition, can match a or b or c followed by either v or z.


- classes cannot extend interfaces, they must implement them.

- the equals() method will return false if the objects are not the same class.

String c = new String("1234567890");
StringBuffer sb = new StringBuffer(c);
- The capacity for sb is now 10+16 = 26

line 10:	Integer e;
1ine 11:	System.out.println(e); 
// compile time error at line 11, not in the previous line!

      double d_num = 999.3568;
      System.out.printf("% .2f", d_num);
Output: 999.36

      Object obj = 99;
      System.out.println(obj);
This looks odd but it compiles.  However, there would be no output.  Not true, 99 will be printed!
By autoboxing, 99 int primitive value will be automatically converted to Integer object and assigned to the variable obj.

Character obj = 65;
char c = 65;
if c==obj ... TRUE

- case labels only accept constant (final) expressions.

The so-called "hashing algorithm" implemented by class Test1 will always retrn the same value, 42, which is legal but will place all of the hash table entries into a single bucket, the most inefficient setup possible.
A **hash function** is any algorithm that maps data of arbitrary length to data of a fixed length. The values returned by a hash function are called hash values, hash codes, hash sums, checksums or simply hashes. 
- every class implicitly or explicitly provides a hashCode() method, which digests the data stored in an instance of the class into a single hash value (a 32-bit signed integer). This hash is used by other code when storing or manipulating the instance – the values are intended to be evenly distributed for varied inputs in order to use in clustering. This property is important to the performance of hash tables and other data structures that store objects in groups ("buckets") based on their computed hash values. Technically, in Java, hashCode() by default is a native method, meaning, it has the modifier 'native', as it is implemented directly in the native code in the JVM.
- a hash table (also hash map) is a data structure used to implement an associative array, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the correct value can be found.

Boolean b1 = new Boolean("TRUE");
boolean b2 = true;
if (b1==b2) // true
if (b1.equals(b2)) // true
if (b1.booleanValue()==b2) // true

// question 20
		Integer arr[] = {2,1,0};
		print(arr);
		...
		public static void print(int...arr)
- Though Integer can be boxed into int type, Integer[] cannot be boxed to int[], so
print(int...arr) cannot be applied to print(Integer[]). and causes a compiler error

		List list2 = new ArrayList<String>();
		list2.add(new StringBuilder("123"));
This will compile because list2 is a raw type variable,
and no checking is done at compile time.
However, if you try this:
String sbu = list2.get(0);
You will get a runtime error: found Object, required String.

class Test {
	public void Test(String a){print(a);}
	public void Test(int b){rint(b);}
	public void Test(){print("None");}
}
Question:  What is printed when you call new Test();?
Answer: Nothing, those are not constructors because of the void return type modifier.

// question 25
int subTotal;
static int total;
public void calculate()
{
	int local;
	local = this.total; //1
	local = this.subTotal; //2
	this.total = total; //3
	//this.local = 4; Cannot find symbol
	//this = new ExamQuestions(); // 5

-  Non-static mehods have an implicit 'this' object reference.  The this reference cannot be changed.  (5)
- The 'this' reference can be used in a non-static context to refer to both instance and static members.
- It cannot be used to refer to locl variables. (see 4)

- Questions 27
public class TestInterface
{
	public abstract class InnerTest
	{
		abstract void f();
	}

	public static void main(String[] args) {
		TestInterface t = new TestInterface();
		//t.f(); // cannot be found
		TestInterface.InnerTest test = t.new InnerTest()
		{
			public void f() 
			{ 
				System.out.println("Inner f");
			}
		};
		test.f(); // works fine
	}
}

- Questions 28 & 29
Protected variables or methods will not be accessable by a sub-class from their parent classes which are in different packages.  For example:

package packages;
public class Account { protected String number = "123"; }
import packages.*;
public class SilverAccount extends Account
{
	public static void main(String[] args) {
		Account gold = new Account();
		// System.out.println(gold.number); <- protected access!
		SilverAccount silver = new SilverAccount();
		System.out.println(silver.number); } // works with the subclass.	
}

- abstract methods cannot define a method body.
public abstract void method(){}
final abstract int method(){}
- both are illegal.  it should be like this:
public abstract void method();

Integer num_123 = Integer.parseInt("123L");
- this method accepts digits only and causes a runtime exception
Integer num_123 = Integer.parseInt(123L);
- compile time error: no suitable method.
parseInt(long)
Integer num_123L = Integer.parseInt(123);
- same error, no method parseInt(int)

- Question 32
static void aMethod() throws RuntimeException
{
	throw new NullPointerException(); // Exception cannot go here.
}
...
	try
	{
		aMethod();
	} catch (ClassCastException cce)
	{
		System.out.println("cce");
	} finally
	{
		System.out.println("finally");
	}


Retesting -------------------------------------------------------


Class A {
	int a =200;
	A(int b) {
		this.a=b;
	}
}
Class Test {
	static void a1(int a) {
		a=-1;
	}
	static void a1(A a) {
	a.a=-1;
	}
	public static void main(String as[]) {
	int a=100;
	a1(a);
	A b = new A(400);
	a1(b);
	System.out.print(a+" "+b.a);
	}
}

Output: 100 -1

Mock Exam 1 Retest
Boolean string1=new Boolean("TrUe");
boolean character1=true;
assert string1.booleanValue()==character1;
assert string1==character1;
assert string1.equals(character1);
//assert !string1.booleanValue()=="true";
assert !string1.equals("true");
//assert !character1=="true";

Vector<String> set = new Vector<String>();
String[]arr=set.toArray();
toArray() returns Object[].  The return type needs to be cast to String[] to compile.
(See repeat question above for answer)

- It's possible to loop an enum with an enhanced for look using the values() method:
enum Direction {
   NORTH,
   EAST,
   SOUTH,
   WEST
}
for (Direction dir : Direction.values()) {
  // do what you want
}

Exam 2 re-rest:

interface IAccount { String getAccoundNumber();}
abstract class Account implements IAccount{}
The class Account is valid as it is declared abstract and therefore doesn't have to implement all the methods of the superclass.

System.out.println(new Integer(0).booleanValue());
There is no such method in the Integer class.

By contract, if two objects are equivalent according to the equals() method, the  the hashCode() method must evaulate them to be ==.  
if (x3.equals(x4))
x3.hashCode() == x4.hashCode();

If a method declararation overrides a method in the super class, there will be a compile time error when:
- there are different return types
- one is void and the other has a return type
- one throws a clause that conflicts with that of any other method that it overrides or hides
However, it can throw unchecked exceptions (RuntimeExceptions and it's descendants)  
Given this:
	public class Customer
	{
    	double calculate(int num) { /* */ }
	}
You can do this:
	double calculate(int num)
	public double calculate(int num)
	protected double calculate(int num)
	double calculate(int num) throws RuntimeException
You cannot do these:
	double calculate(int num) throws Exception
	private double calculate(int num)

Throwable
Exception
ClassNotFoundException
CloneNotSupportedException
IllegalAccessException
IntantiationException
InterruptedException
NoSUchMethodExcption

RuntimeException
ArithmethicException
ArrayStoreException
ClassCastException
IllegalArgumentException (nfe)
IllegalMonitorStateException
IndexOutOfBoundsException (aioobe)
NegativeArraySizeException
NullPointerException
SecurityException

class Test6<Ob>
{
	static Ob getOb()
	{
		// error: non-static type variable Ob 
		// cannot be referenced from a static
		// context.
		return null;
	}
}

- remember, abstract methods do not have a body!
abstract void f();

String str = "10";
int a = new Integer(10);
boolean b = str == a;
// incomparable types: String and int
//only the + operator performs implicit conversion to a String object.

- finalize will always run before an object is garbage collected.

- Member inner classes are the static class

- priavte synchronized int e; is an invalid class level (nonlocal) variable declaration.

class A {A() {System.out.print("Super ");}}
public class Main extends A {
    public static void main(String [] args) {
        new Main(1L).Main();
    }
    public Main(int x) {
        this();
        System.out.print(" " + (x * 2));
    }
    public Main(long x) {
        this((int) x);
        System.out.print(" " + x);
    }
    public Main() {
        super(); 
        System.out.print("No arg Sub");
    }
    void Main() {
        System.out.print(" method "); 
    }
}

- Watch out!!! You cannot assign a value to a variable declared in an interface even when the class at hand implements that interface, as all interface variables are implicitly final!

Methods shared by the String and the Pattern class:
- split
- matches

- An inner class can be delcared public, final, abstract.
- A local (ineer) class can have static members provided that they are constant variables.

		double num1 = 0.2;
		float num2 = 0.2f;
		System.out.println(num1 == num2); // false
		System.out.println(num1 == (double)num2); // false
		System.out.println((float)num1 == num2); // true
		Integer num3 = 123;
		float num4 = 123f;
		double num5 = 123;
		float num6 = 123;
		Integer num7 = new Integer("123");
		byte num8 = 123;
		System.out.println("Integer == float "+(num3 == num3)); //true
		System.out.println("double == float "+(num5 == num4));  // true
		System.out.println("float == int "+(num6 == num7));     // true
		System.out.println("int == byte? "+(num7 == num8));     // true


public static void main(String [] args) {}
public void main(String ...arg){}
- This class will not compile as the method signatures are the same.

- casting from a child class to a parent class is called implicit casting.

- Object references are passed by value. Additionally Strings are immutable.  Passing  a String to a method creates a new string object that the copy of the reference now points to. The original reference still points to the original string.
It would be like creating a new String object.
void foo( object o )
{
    o = new Object( );  // original reference still points to old value on the heap
}

- There is a BIG difference between overriding and overloading methods!


During serialization,
- state is saved but methods are not.
- transient and static variables are not.
- objects that inerhit Externalizable are.

by implementating java.io.Serializable, you get "automatic" serialization capability for objects of your class. No need to implement any other logic, it'll just work. The Java runtime will use reflection to figure out how to marshal and unmarshal your objects.

In earlier version of Java, reflection was very slow, and so serializaing large object graphs (e.g. in client-server RMI applications) was a bit of a performance problem. To handle this situation, the java.io.Externalizable interface was provided, which is like java.io.Serializable but with custom-written mechanisms to perform the marshalling and unmarshalling functions (you need to implement readExternal and writeExternal methods on your class).

- You can only implement interfaces:
class Outside implements String // interface expected

Integer numm1 = 0;
Float numm2 = -0.0F;
(numm1.intValue() == numm2)) true
Float numm3 = 0.0F;
(numm1.intValue() == numm3)) true


4 + 5 * 6 / 3 will be treated as 
4 + (5 * (6 / 3)) = ?

When two operators share an operand then operator with the higher precedence gets evaluated first. However, if the operators  have the equal precedence in the same expression then that  expression will be evaluated from left to right except the assignment operators:
a = b = c = 15 is treated as 
a = (b = (c = 15))	

int a = 6;
int b = 5;
int c = 10;
rs = a + (++b)* ((c / a)* b);

x = y = z = 17 
right-to-left associativity
s x = (y = (z = 17))

72 / 2 / 3 
the / operator has left-to-right associativity.
(72 / 2) / 3

int x = 5;
int y = 10;
int z = ++x * y--;
z = 60

	int i = 1;
	int j = 1;
	int k = ++i * j++;  // ijk is 2-2-2

System.out.println("abc " + 1 + 2); = abc 12
System.out.println("abc " + (1 + 2)); = abc 3
System.out.println(1 + 2 + " abc"); = 3 abc!!!  The + operator is left associative, whether it is string concatenation or arithmetic plus.

year % 4 == 0 && year % 100 != 0 || year % 400 == 0

((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)

int a = 1;         
int x = ++a + a++;         
System.out.print(x); // Prints 4 
a becomes 2, even tho the a++ has a higher precedence.
Precedence determines which operands bind to which operators.
Precedence only comes into play if they compete over the same occurrence of an operand. For example: -a++; 
Operator precedence only determines *what* is evaluated, not *when* it is evaluated.
(from left to right) as -(a++) because post-increment has higher precedence than negation. 
Precedence has to do with which operands bind to which operators. It has nothing to do with order of execution. Order of execution (evaluation) is *always* left-to-right in Java. 

int x = 1;  
int y = 1;  
x += y += x += y;  

1 += y += x += y; // evaluate x  
1 += 1 += x += y; // evaluate y  
1 += 1 += 1 += y; // evaluate x, x is still 1 cause no addition takes place yet  
1 += 1 += 1 += 1; // evaluate y  
1 += 1 += 2;      // x is now 2  
1 += 3;           // y is now 3  
4;                // x is now 4  

int y = 1;
y+ = ++y +y++; 
y = y + ++y +y++;
y = y + (++y + y++); ?
y = y++ + (y + y++); ?
y=1 + 2 + 2 

int x = 5;  
int z = ++x * x * x--; // Prints 216  

	i = 10; a = 0;
	int b, c, d; 
	a = (b = i++) + (c = ++i) + (d = i--); 
	//    10			12			12

	int x = 5;  
    int z = ++x * x--;  
The output is 36 because x is incremented first.
x = 5
x++ * --x
This is 25.

byte b1 = 1;
byte b2 = 2;
b1 = b1 + b2; // compilation fails
b1 += b2; // compilation successful

interface Rideable 
{
	String getGait();
}
public class Camel implements Rideable 
{
	int weight = 2;
	public static void main(String[] args) 
	{
		new Camel().go(8);
	}
	void go(int speed) 
	{
		++speed;
		weight++;
		int walkrate = speed * weight;
		System.out.print(walkrate + getGait());
	}
	String getGait() 
	{
		return " mph, lope";
	}
}
```
error: getGait() in Camel cannot implement getGait() in Rideable
attempting to assign weaker access privileges; was public
- This happens becuase "methods in an interface are implicitly public, so the public modifier can be omitted." but the default for a class is package private.

class A.  class B extends A.
A a = new B().go() output: B
B b = new A() compile error- incompatible types: required: A found: B 


Arrays are objects, so
int a[] = {1,2,3,4}
print(a instanceof Object) prints true.

boolean a = true;
boolean b = false;
boolean c = true;
if (a && (b = c)) 
- an assignment statement also has a value equal to the value being 
assigned, hence (b = c) evaluates to true and subsequently a 
(b = c) evaluates to true

float x = 0.1f;
while (x != 1.1) 
{
	System.out.printf("x = %f%n", x);
	x = x + 0.1f;
}

The number 0.1 cannot be stored precisely in base two in the same way that the
decimal equivalent of the fraction 1/3 cannot be represented exactly (0.333333…).  The result of adding this number repeatedly to x will result in a number that is not quite 1.1. The comparison, x != 1.1, will return true and the loop will never end.  The output of the printf statement does not show this difference:
...
x = 0.900000
x = 1.000000
x = 1.100000
x = 1.200000
x = 1.300000
...

-0.0 == 0.0 is true.

------------ final mock exam --------------------

- creating a class without a no args constructor causes a COMPILER error when creating the class with a no args constructor!!!

//package java.lang;
public class ExtendedObject extends java.lang.Object
{
		String name = "DEFAULT VALUE";
		protected void finalize() { name = null; }
		public static void main(String as[]) throws Throwable
		{
			Object ob = new ExtendedObject();
			ob.finalize();
			System.out.println(ob);
		}
}

a. the code will not compinle
b. by uncommenting line 1, it will compile.

The finalize() method is declared as protected in the class Object, so it cannot be invoked from code in other packages.  The compile error msg says finalize() has protected access in java.lang.Object
If we use the same package java.lang then the code will compile, but at runtime a SecurityException will be thrown stating that prohibited package name:java.lang.
When we ran the class with the uncommented package line, we got a java.lang.NoClassDefFoundError runtime error.
The same behavior would be found if we eliminate the extends part.  Here is some discussion about that.
"Unless the Object class is not actually the java.lang.Object class (the tutorial does not include the imports, so it's hard to see), the extends Object is redundant."
"Extends clause is optional as stated in Java Language Specification. If it is omitted, the class is derived from java.lang.Object. It is just a matter of coding style to write it or not to write it in this case. Usually it is omitted."

public class Test {
	static int i = j;
	static int j = 10;
}
Compile error: illegal forward reference.
Another uninitialized gotcha:
		int y;
		System.out.println("y before init "+y);
		y = 100;
Even tyring to print an unitialized variable fails upon compile with the error: variable y might not have been initialized. 

public class Test8
{
	static String s1 = "Java";
	public static void main(String args[]) {
		String s2 = "Java";
		String s3 = new String(s1);
		System.out.println(s1==s2);        // 8. true
		System.out.println(s1.equals(s2)); // 9. true
		System.out.println(s3==s1); 	   // 10.false
		System.out.println(s3.equals(1));  // 11.false
		System.out.println(Test9.s4==s1);  // 12.true
	}
}
class Test9
{
	static String s4 = "Java";
}
Only line 10 will print false.  Strings are immutable objects.  That is, a string is read only once the string has been created and initialized, and Java optimizes handling of string literals; only one anonymous string object is shared by all string literals with the same contents.  Hence in the above code, the strings s1, s2 and s4 reger to the same anonymous string object, initialized with the character string "Java".  This, s1 ==s2 and Test9.s4 will both return true and obviously s1.equals(s2) will return true.

public class AccountBal
{
	public int getBalance(Short amt){return amt*2;}
	public double getBalance(double amt){return amt*3;}
	//public long getBalance(long amt){return amt*4;}
	public static void main(String[] args) {
		AccountBal ac = new AccountBal();
		Integer val = 20;
		System.out.println(ac.getBalance(val));
	}
}
Our choice was:
1 code will not compile
2 if you uncomment the long method, the code will compile, run and print 80.
The lab answer said the code will comple, run and print 60.0
The lab notes state: The getBalance() call made from the main method with an int argument calls the getBalace(double amt) method and prints 60.0.  Because short cannot hold an int.  If we uncomment getBalance(long amt) method then the getBalance(double amt) will not be called and hence 80 will be printed out.
Is this a rules of promotion thing?  With an Integer, what other types will work?
int fits with double
That's Integer actually.
float only goes to float.
 float will not fit into a Float, but a double.  
 If we cancel out the double, then it will fit into the Float method.
 float to float, double, Float, end.
 Float Float, float, double, end.
 int to int, long, float, double, Integer, end.
 Integer to Integer, int, long, float, double, end
 byte to byte, short, int, long, float, double, Byte, end.
 Byte to Byte, byte, short, int...
 char to char, int, long, float, double, Character, end.
 Character to Character, char, int, long, float, double, end.
 short to short, int, long, float, double, Short, end.
 Short to Short, short, int, long, float, double, end.
 float double Float end.
 long to long, float, double, Long, end.
That's the opposite to the rules of promotion, which we had as double, float, long, int.  So the order for primitives is:
int
long
float
double
Wrapper class.
For a wrapper class, it slips that last step.

enum Month {JAN,FEB,MAR,APR,MY}
public class Test10
{
	public static void main(String[] args) {
		Month mon = Month.valueOf("JAN");
		if(mon==Month.JAN)
			System.out.println("Inside JAN");
		if(mon.equals(Month.JAN))
			System.out.println("Inside JAN");
	}
}
The valueOf() method returns the enum constant whose vluae corresponds to the string argument passed in.  The enum constant can be compared for == relational operator or the equals() method, since they are instances of the declared enumeration type.

local variables can be declared as final and cannot be declared static private, public or protected.  Local variables are defined in the bodies of methods.  Trying to use any declaration besides static will cause a compile error that says: illegal start of expression

class TestOuter
{
	static Integer num = 200;

	TestOuter()
	{
		num = 400;
	}

	static class TestInner
	{
		TestInner()
		{
			System.out.print(num);
		}
	}

	public static void main(String[] args) {
		new TestOuter.TestInner();
	}
}

What will be printed?  Static nested classes are allowed to access static variables of the enclosing class.  So 200 will be printed.  The OuterClass is never instantiated, so the value is not changed by the constructor.  If we put this before the call, TestOuter to = new TestOuter();, 400 will be printed.

public class Test11
{
	public static void main(String[] args) 
	{
		Integer  arg = 20;
		switch(arg)
		{
			default:
				System.out.println("default");
			case 10:
				System.out.println("100");
			case 20:
				System.out.println("200");
		}
	}
}
The class compiles and runs fine.  Obviously the position of the dafult case doesn't matter.  The Integer wrapper class in unboxed and 200 is printed out.


String str = "Java*JSP*EJB*J2EE";
System.out.println(Arrays.toString(str.split("*",-2)));
java.util.regex.PatternSyntaxException: Dangling meta character * near index 0.
PatternSysntaxException occurs if the regular expressions's syntx is invalid.  Note that to use "*" as a delimiter, we have to specify "\\*" as the regular expression.  Given that, we would split the string into:
[Java, JSP, EJB, J2EE]
Also, the -2 is not needed; the same output is got without it.
The limit parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array. If the limit n is greater than zero then the pattern will be applied at most n - 1 times, the array's length will be no greater than n, and the array's last entry will contain all input beyond the last matched delimiter. If n is non-positive then the pattern will be applied as many times as possible and the array can have any length. If n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded.
The string "boo:and:foo", for example, yields the following results with these parameters:
Regex	Limit	Result
:	2	{ "boo", "and:foo" }
:	5	{ "boo", "and", "foo" }
:	-2	{ "boo", "and", "foo" }
o	5	{ "b", "", ":and:f", "", "" }
o	-2	{ "b", "", ":and:f", "", "" }
o	0	{ "b", "", ":and:f" }
An invocation of this method of the form str.split(regex, n) yields the same result as the expression:
Pattern.compile(regex).split(str, n)

		Vector<String> employeeList = new Vector<String>();
		Vector<Integer> employeeIdList = new Vector<Integer>();
		Vector<Object> employeeProfileList = new Vector<Object>();
		System.out.println(employeeList.getClass() == employeeIdList.getClass());
		System.out.println(employeeList.equals(employeeProfileList));
		System.out.println(employeeList.getClass() == employeeProfileList.getClass());
		System.out.println(employeeIdList.equals(employeeProfileList));
All instances of a generic class have the same runtime class, regardless of their actual type parameters.  So the getClass() method returns a java.util.Vector for both x and y.  Since no data has been added to both Vector objects, they are also meaningfully equal.  So the equals method returns true here and the output is true, true, true, true.

- logical operators &&,||, ! and ?: always use boolean operands. 
- bitwise operators and shift operators allow numeric operands.

- primitives and String objects will not be changed in methods.  Other objects can be changed.

method()
{
	int x = 10;
	int y;
	if (x < 100) y = 100;
		if (x >= 100) y = x * 10;
			print("Y is "+y);
}
- Will not compile with the warning that the variable y may not have been initialized.

This will not compile:

import java.util.*;

class Test13
{
	public static void main(String[] args) {
		ArrayList<String> a =new ArrayList<String>();
		a.add("one");
		a.add("two");
		a.add("three");
		String[] s = a.toArray();
		for (String str:s)
		{
			System.out.println(str);
		}
	}
}

Remeber, the toArray() method returns an array of Objects, and needs to be cast to a String array like this:
String[] s = a.toArray(new String[0]);
Trying this fails during runtime:
String[] s = (String[])a.toArray();
ClassCastException: Object cannot be cast to String.
Yeah right.  An Object has never been cast to a String before.  Anyhow, how did we do this before?  Can't remember and time to move on.  However, before we move on,
String[] s = a.toArray(new String[a.size()]);
works also.  If we choose size 4, then a null string is added to the list.

Remeber in Test3.java?
		Set<Test3> s = new TreeSet<Test3>();
		s.add(new Test3()); // Test3 cannot be cast to Comparable.
Our notes state: Either Test3 has to implement Comparable, or you need to provide a comparator when creating the TreeSet.
Alos note this is a RUNTIME error, and the code actually compiles fine, although that seems a little strange in the rigid world of Java.
ClassCastException: Test3 cannot be cast to Comparable.
If we used an ArrayList, then there would be no problem, like this:
ArrayList s = new ArrayList();
Then we get a compile time error in the for loop:
error: incompatible types.  required Test3
found Object
		for (Test3 out: s)
				        ^
Not sure how to fix it.  But the second similar looking question does this:
given:
class A{}
class B extends A{}
class C extends B{}
Will this compile?
		ArrayList a = new ArrayList();
		a.add(new A());
		a.add(new B());
		a.add(new C());
		for (Object object:a)
			System.out.println(object);
A generic type used without type parameters is know as a raw type.  In the above example we assign the generic types to the raw type variable, and then insert different types of objects into it.  The raw type is not type-checked, hence there are no compiler errors but warnings are thrown.  The code also runs fine =)~

Given the Customer is a class:
1. Customer []c1 = new Customer[10];
2. Customer [][]c2 = new Customer[10][];
3. c2[0] = new Customer[5];
4. print(c1[0]); // prints null
5. print(c2[1][0]); 
In the case of arrays, initialization is supposed to be complete when we specify the leftmost dimension of the array.  The problem occurs at runtime if we try to access an element of the array which has not been initialized (specification of size).  In the question above there is no problem until line 5.  We are tyring to access c2[1][0] whereas we have only initialized c2[0].  In other words we can access any element in cs[0] row but not any other element which is in any row other than c2[0].  Therefore accessing c2[1][0] will cause a runtime exception (npe).

Now, onto threads:
public class MyThread extends Thread
{
	MyThread(int i)
	{
		this.i = i;
	}
	static int i = 0;
	public void run()
	{
		System.out.println(i);
	}
	public static void main(String[] args) {
		for(int i = 0; i < 10; i++)
		{
			new Thread().start();
		}
	}
}
Will this compile and run?  Notice MyThread is not started, but Thread.  To start MyThread, we need to supply an argument:
new MyThread(11).start();
This will print 11 ten times.  Should we go over the threads tutorial, even though threads are sposed to be in the OCP exam?  sab.

