Sample Questions Four - Practice Test 2.

Encapsulation
Working with Java Data Types: String, StringBuilder x 2
Handling Exceptions x 4
Java Basics x 3
Working with Inheritance x 8
Working with Java Data Types - variables and Objects x 2n
Overloading Methods
Using Loop Constructs x 5
Working with methods - Access Modifiers
Java Basics - Garbage Collection
Using Operators and Decision Constructs x 9
Creating and Using Arrays x 3

*Encapsulation* -------------------------------------------

Question:
Consider the following class written by a novice programmer.
class Elliptical{
    public int radiusA, radiusB;
    public int sum = 100;
    public void setRadius(int r){
        if(r>99) throw new IllegalArgumentException();
        radiusA = r;
        radiusB = sum - radiusA;
    }
}
After some time, the requirements changed and the programmer now wants to make sure that radiusB is always (200 - radiusA) instead of (100 - radiusA) without breaking existing code that other people have written. Can she accomplish her goal?
1. Make sum = 200 and make all fields (radiusA, radiusB, and sum) private.
2. Write another method setRadius2(int r) and set radiusB accordingly in this method.
3. She cannot.

Answer:
1. This should have been done when the class was first written.
setRadius method makes sure that radiusB is set to sum - radiusA. So changing sum to 200 should do it. However, note that radiusA, radiusB, and sum are public which means that any other class can access these fields directly without going through the setRadius method. So there is no way to make sure that the value of radiusB is correctly set at all times. If you make them private now, other classes that are accessing the fields directly will break.
The class should have been coded with proper encapsulation of the fields in the first place.
Correct response: 3.

*Working with Java Data Types: String, StringBuilder* -----

Question:
What will be written to the standard output when the following program is run?  
public class TrimTest{    
	public static void main(String args[]){       
		String blank  = " ";  // one space       
		String line = blank + "hello" + blank + blank;       
		line.concat("world");       
		String newLine  =  line.trim();       
		System.out.println((int)(line.length() + newLine.length()));    
	} 
}

Answer:
Note that line.concat("world") does not change line itself. It creates a new String object containing " hello world  " but it is lost because there is no reference to it.
Similarly, calling trim() does not change the object itself.
So the answer is 8 + 5 = 13 !


Question:
Which of the following methods modify the object on which they are called?
1. setValue(int)of java.lang.Integer class.
2. The substring(int) method of the String class
3. The replace() method of the String class.
4. The reverse() method of the StringBuffer class.

Answer:
1. There is no such method in Integer class. Note that Integer, Float and other such wrapper objects are immutable. 
2. String is an immutable object. calling substring(...) returns a new different String object. It cannot change the original object.
3. String objects can never be modified once created.
Correct response: 4.
Similar question on immutable wrapper classes:
Given:
1. class Ring {
2. 	final static int x2 = 7;
3. 	final static Integer x4 = 8;
4. 	public static void main(String[] args) {
5. 		Integer x1 = 5;
6. 		String s = "a";
7. 		if(x1 < 9) s += "b";
8. 		switch(x1) {
9. 			case 5: s += "c";
10. 		case x2: s += "d";
11. 		case x4: s += "e";
12. 	}
13. 	System.out.println(s);
14. 	}
15. }
What is the result?
A. abc
B. abcde
C. Compilation fails due only to an error on line 7.
D. Compilation fails due only to an error on line 8.
E. Compilation fails due only to an error on line 10.
F. Compilation fails due only to an error on line 11.
G. Compilation fails due to errors on multiple lines.

Answer:
A switch statement requires its case expressions to be constants, and wrapper variables (even final static ones) aren�t considered constants. The rest of the code is correct.
x2 is final static, how would it go through? (just because it is not a wrapper class?)
An instance of a wrapper class is not a constant expression. (In practice it is constant because the wrapper classes are immutable, but the Java compiler doesn't know that the wrapper classes are immutable).
Correct response: F. 

*Handling Exceptions* -------------------------------------

Question:
What will the following code print?
public class Test{
   public int luckyNumber(int seed){
      if(seed > 10) return seed%10;
         int x = 0;
            try{
               if(seed%2 == 0) throw new Exception("No Even no.");
               else return x;
            }
            catch(Exception e){
               return 3;
            }
            finally{
               return 7;
            }
         }

        public static void main(String args[]){
           int amount = 100, seed = 6;
           switch( new Test().luckyNumber(6) ){
               case 3: amount = amount * 2;
               case 7: amount = amount * 2;
               case 6: amount = amount + amount;
               default :
           }
          System.out.println(amount);
       }
}

Answer:
When you pass 6 to luckyNumber(), if(seed%2 == 0) throw new Exception("No Even no."); is executed and the exception is caught by the catch block where it tries to return 3; But as there is a finally associated with the try/catch block, it is executed before anything is returned. Now, as finally has return 7;, this value supersedes 3. 
In fact, this method will always return 7 if seed <= 10.  
Now, in the switch there is no break statement. 
So both - 
case 7: amount = amount * 2; 
and 
case 6: amount = amount + amount; are executed.
So the final amount becomes 400.


Question:
Consider the following code snippet:
void m1() throws Exception{
   try{
      // line1
   }
   catch (IOException e){
       throw new SQLException();
   }
   catch(SQLException e){
       throw new InstantiationException();
   }
   finally{
      throw new CloneNotSupportedException();   // this is not a RuntimeException.
   }
}
Which of the following statements are true?
1. If IOException gets thrown at line1, then the whole method will end up throwing SQLException.
2. If IOException gets thrown at line1, then the whole method will end up throwing CloneNotSupportedException.
3. If no exception is thrown at line1, then the whole method will end up throwing CloneNotSupportedException.
4. If SQLException gets thrown at line1, then the whole method will end up throwing InstantiationException()

Answer:
The fundamental concepts at play here are:
1. The Exception that is thrown in the last, is the Exception that is thrown by the method to the caller.
So, when no exception or any exception is thrown at line 1, the control goes to finally or some catch block. Now, even if the catch blocks throws some exception, the control goes to finally. The finally block throws CloneNotSupportedException, so the method ends up throwing CloneNotSupportedException. Other exceptions thrown by the code prior to this point are lost.
2. Exception thrown by a catch cannot be caught by the following catch blocks at the same level. So, if IOException is thrown at line 1, the control goes to first catch which throws SQLException. Now, although there is a catch for SQLException, it won't catch the exception because it is at the same level. So, the control goes to the finally and same process as explained above continues. Any exceptions thrown before this exception are lost.
Correct response: 2 and 3.

Question:
Identify the correct constructs.
1. 
try {
  for( ;; );
}finally { }

2.
try {
       s = new ServerSocket(3030); 
} 
catch(Exception t){ t.printStackTrace(); } 
catch(IOException e) { 
    s = new ServerSocket(4040);
}
catch(Throwable t){ t.printStackTrace();  }

3.
int x = validMethod();
try {
  if(x == 5) throw new IOException();
  else if(x == 6) throw new Exception();
}finally {
 x = 8;
}
catch(Exception e){ x = 9; }

Answer:
1. A try block must be accompanied by either a catch block or a finally block or both.
2. You can have any number of catch blocks in any order but each catch must be of a different type. Also, a catch for a subclass exception should occur before a catch block for the superclass exception. Here, IOException is placed before Throwable, which is good but Exception is placed before IOException, which is invalid and will not compile.
3. finally cannot occur before any catch block.
Correct response: 2.
Note that a try with resources block may or may not to have any catch or finally block at all. However, try with resources is not in scope for this exam.

Question:
What will the following program print when run using the command line: java TestClass   
public class TestClass {     
	public static void methodX() throws Exception {       
		throw new AssertionError();    
	}       
	public static void main(String[] args) {       
		try{          
			methodX();       
		} catch (Exception e) {         
			System.out.println("EXCEPTION");       
		}    
	} 
}
1. It will throw AssertionError out of the main method.
2. It will print EXCEPTION.
3. It will not compile because of the throws clause in methodX().
4. It will end without printing anything because assertions are disabled by default.

Answer:
1. A subclass of Error cannot be caught using a catch block for Exception because java.lang.Error does not extend java.lang.Exception. 
2. The catch block will not be able to catch the Error thrown by methodX().
3. The throws clause is valid even though unnecessary in this case.
4. It is true that assertions are disabled by default however, methodX is throwing an AssertionError explicitly like any other Throwable. Here, the assertion mechanism is not even used.
Correct response: 1.

*Java Basics* ---------------------------------------------

Question:
An instance member ...
1. can be a variable, a constant or a method.
2. belongs to an instance of the class.
3. is same as a local variable.

ANswer:
3. variables defined in methods are called local variables (also known as automatic variables) where as instance members are defined in the class scope.
An instance member belongs to a single instance, not the class as a whole. An instance member is a member variable or a member method that belongs to a specific object instance. All non-static members are instance members.
Correct response: 1 & 2



Question:
Which of the following are valid declarations:
1. int a = b = c = 100;
2. int a, b, c; a = b = c = 100;
3. int a, b, c=100;
4. int a=100, b, c;

Answer:
1. Chaining to use a value of a variable at the time of declaration is not allowed. Had b and c been already declared, it would have been valid. For example, the following is valid:   
int  b = 0, c = 0;   
int a = b = c = 100; 
Even the following is valid:   
int  b , c;  //Not initializing b and c here.   
int a = b = c = 100; //declaring a and initializing c, b, and a at the same time. 
Notice the order of initialization of the variables - c is initialized first, b is initialized next by assigning to it the value of c. Finally, a is initialized.
Java does not allow chained initialization in declaration so option 1 is not valid.
Correct repsonse: 2, 3, 4.

Question:  Will the following code compile and run?
static import java.lang.System.*;//1
class $$//2
{
	static public void main(String... _$_) //3
	{
		String _ = ""; //4
		for(int $=0; ++$ < _$_.length; ) //5
			_ += _$_[$]; //6
		out.println(_); //7
	}
}

Answer:
Everything here is valid, except the import statement, which should be import static ...
Reverse these two words and everything will compile fine.
Correct response: no.

*Working with Inheritance* --------------------------------

Question:
Given the following class definitions :
interface MyIface{};
class A {};
class B extends A implements MyIface{};
class C implements MyIface{};
and the following object instantiations:
  A a = new A();
  B b = new B();
  C c = new C();
Which of the following assignments are legal at compile time?
1. c = b;
2. MyIface i = c;
3. c = (C) b;

Answer:
1. There is no relation between b and c.
2. Because C implements I.
3. Compiler can see that in no case can an object referred to by b can be of class c. So it is a compile time error.
The statements c = b and b = c are illegal, since neither of the classes C and B is a subclass of the other. Even though a cast is provided, the statement c = (C) b is illegal because the object referred to by b cannot ever be of type C.
Correct response: 2.

Question:
interface Flyer{ }
class Bird implements Flyer { }
class Eagle extends Bird { }
class Bat { }
public class TestClass {    
    public static void main(String[] args) {
        Flyer f = new Eagle();
        Eagle e = new Eagle();
        Bat b = new Bat();
        if(f instanceof Flyer) System.out.println("f is a Flyer");
        if(e instanceof Bird) System.out.println("e is a Bird");
        if(b instanceof Bird) System.out.println("f is a Bird");
    }
}
What will be printed when the above code is compiled and run?

Answer:
b points to an object of class Bat, which does not extend from Bird. Now, it is possible for b to point to an object of any subclass of Bat. However, it is not possible for that sub class to extend Bird (because a class can at most extend from only one class). Therefore, it is not possible for b to point to an object of a class that extends Bird. The compiler figures out this fact at compile time itself and so the code fails to compile.
Therefore you cannot call instanceof on unrelated classes.  If Bat did extend Bird or Flyer even, the code would compile.  Or, if the b instanceof Bird line is removed, the output would be:
f is a Flyer
e is a Bird
At run time, f points to an object of class Eagle. Now, Eagle extends Bird, which implements Flyer so f instanceof Flyer returns true.
e points to an object of class Eagle. Eagle extends Bird. Therefore, e instanceof Bird will also return true.
Correct response:  The class will not compile, error: incovertible types.
(See Test30.java)

Question:
Consider the following code:
class Super { static String ID = "QBANK"; }
class Sub extends Super{
   static { System.out.print("In Sub"); }
}
public class Test{
   public static void main(String[] args){
      System.out.println(Sub.ID);
   }
}
What will be the output when class Test is run?

Answer:
As per Section 12.4.1 given here: http://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html
A class or interface type T will be initialized immediately before the first occurrence of any one of the following:
T is a class and an instance of T is created.
T is a class and a static method declared by T is invoked.
A static field declared by T is assigned.
A static field declared by T is used and the field is not a constant variable (§4.12.4).
T is a top level class (§7.6), and an assert statement (§14.10) lexically nested within T (§8.1.3) is executed.
A reference to a static field (§8.3.1.1) causes initialization of only the class or interface that actually declares it, even though it might be referred to through the name of a subclass, a subinterface, or a class that implements an interface.
Invocation of certain reflective methods in class Class and in package java.lang.reflect also causes class or interface initialization.
A class or interface will not be initialized under any other circumstance.
Correct response:  DOn't know what any of that means, but the program will print QBANK.
(See Test28.java)

Question:
Which statement regarding the following code is correct?

class A{
   public int i = 10;
   private int j = 20;
}

class B extends A{
   private int i = 30; //1
   public int k = 40;
}

class C extends B{ }

public class TestClass{
   public static void main(String args[]){
      C c = new C();
      System.out.println(c.i); //2
      System.out.println(c.j); //3
      System.out.println(c.k); 
   }
}
1. It will print 10 and 40 if //3 is commented.
2. It will print 40 if //2 and //3 are commented.
3. It will not compile because of //1.
4. It will compile if //2 is commented.

Answer:
You cannot access c.i because i is private in B. But you can access ( (A)c).i because i is public in A. Remember that member variables are shadowed and not overridden. So, B's i shadows A's i and since B's i is private, you can't access A's i unless you cast the reference to A. You cannot access c.j because j is private in A.
If we add this line in class B: public int j = 50; then j in B can be read and 50, 40 will be printed.
Correct response: 2.
(See Test27.java)

Question: 
Consider the following class hierarchy (B1 and B2 are subclasses of A and C1, C2 are subclasses of B1)  Assume that method public void m1(){ ... } is defined in all of these classes EXCEPT B1 and C1.  Assume that "objectOfXX" means a variable that points to an object of class XX. So, objectOfC1 means a reference variable that is pointing to an object of class C1.  Which of the following statements are correct?
1. objectOfC1.m1(); will cause a compilation error.
2. objectOfC2.m1(); will cause A's m1() to be called.
3. objectOfC1.m1(); will cause A's m1() to be called.
4. objectOfB1.m1(); will cause an exception at runtime.
5. objectOfB2.m1(); will cause an exception at runtime.

Answer: 
1 & 3 C1 will inherit B1's m1() which in turn inherits m1() from A.
2. C2 has m1(), so its m1() will override A's m1().
4. B1 will inherit m1() from A. So this is valid.
5. B2 overrides m1() of A. So there will be no exception.
Correct response: 3

Question:
Consider that you are writing a set of classes related to a new Data Transmission Protocol and have created your own exception hierarchy derived from java.lang.Exception as follows:
enthu.trans.ChannelException
              +-- enthu.trans.DataFloodingException, 
                    enthu.trans.FrameCollisionException
You have a TransSocket class that has the following method: 
   long connect(String ipAddr) throws ChannelException
Now, you also want to write another "AdvancedTransSocket" class, derived from "TransSocket" which overrides the above mentioned method. Which of the following are valid declaration of the overriding method?
1. int connect(String ipAddr) throws ChannelException
2. long connect(String ipAddr) throws FrameCollisionException
3. long connect(String ipAddr) throws Exception
4. long connect(String str)

Answer:
There are 2 important concepts involved here:
1. The overriding method must have same return type in case of primitives (a subclass is allowed in case of classes)  (Therefore, the choices returning int are not valid.) and the parameter list must be the same (The name of the parameter does not matter, just the Type is important). 
2. The overriding method can throw a subset of the exception or subclass of the exceptions thrown by the overridden class. Having no throws clause is also valid since an empty set is a valid subset. 
Answer 3: This option is invalid because Exception is a super class of ChannelException so it cannot be thrown by the overriding method.
Correct response: 2 and 4.

Question:
Which statements concerning the following code are true?
class A{
  public A() {} // A1
  public A(String s) {  this();  System.out.println("A :"+s);  }  // A2
}

class B extends A{
  public int B(String s) {  System.out.println("B :"+s);  return 0; } // B1
}
class C extends B{
    private C(){ super(); } // C1
    public C(String s){  this();  System.out.println("C :"+s);  } // C2
    public C(int i){} // C3
}
1. At least one of the constructors of each class is called as a result of constructing an object of class C.
2. Constructor at  //A2 will never be called in creation of an object of class C.
3. Class C can be instantiated only in two ways by users of this class.
4. //B1 will never be called in creation of objects of class A, B, or C.
5. The code will not compile. 

Answer:
Note: The C1 constructor will call A1.
1. To create any object one and only one constructor of that class and each of the super classes is called. (A constructor may delegate the construction to another constructor of the same class by calling this(...) as the first statement.)
2. Because B has no defined constructor and so a default no-argument constructor will be called, which will call the no-argument constructor of A
3. Since one constructor is private, users of this class can use only the other two public constructors from outside this class.
4. Because //B1 is not a constructor. Note that it is returning an int. A constructor does not have any return type, not even void.
Correct response: 1,2,3,4.

Question:
Which statements concerning the following code are true?

class A{
  public A() {} // A1
  public A(String s) {  this();  System.out.println("A :"+s);  }  // A2
}

class B extends A{
  public int B(String s) {  System.out.println("B :"+s);  return 0; } // B1
}
class C extends B{
    private C(){ super(); } // C1
    public C(String s){  this();  System.out.println("C :"+s);  } // C2
    public C(int i){} // C3
}
1. At least one of the constructors of each class is called as a result of constructing an object of class C.
2. Constructor at  //A2 will never be called in creation of an object of class C.
3. Class C can be instantiated only in two ways by users of this class.
4. //B1 will never be called in creation of objects of class A, B, or C.
5. The code will not compile. 

Answer:
1. To create any object one and only one constructor of that class and each of the super classes is called. (A constructor may delegate the construction to another constructor of the same class by calling this(...) as the first statement.)
2. Because B has no defined constructor and so a default no-argument constructor will be called, which will call the no-argument constructor of A
3. Since one constructor is private, users of this class can use only the other two public constructors from outside this class.
4. //B1 will never be called in creation of objects of class A, B, or C.
Correct response:

Question: Which of the following statements are correct?
1. An interface can be extended by an abstract class.
2. An interface can be extended by a concrete class.
3. An abstract class cannot implement an interface.
Answer:
1. A class "implements" an interface. It does not "extend" an interface.
3. Any class, whether abstract or concrete, can implement any interface.
Correct response: 1, 2, and 3 are all wrong.


*Working with Java Data Types - variables and Objects* ----

Question:
What will be the result of attempting to compile and run the following code?
public class InitClass{
   public static void main(String args[ ] ){
      InitClass obj = new InitClass(5);
   }
   int m;
   static int i1 = 5;
   static int i2 ;
   int  j = 100;
   int x;
   public InitClass(int m){
      System.out.println(i1 + "  " + i2 + "   " + x + "  " + j + "  " + m);
   }
  { j = 30; i2 = 40; }  // Instance Initializer
   static { i1++; }      // Static Initializer
}

Answer:
The value 5 is passed to the constructor to the local (automatic) variable m. So the instance variable m is shadowed. Before the body of the constructor is executed, the instance initializer is executed and assigns values 30 and 40 to variables j and i2, respectively. A class is loaded when it is first used. For example,
class A1{
  static int i = 10;
  static { System.out.println("A1 Loaded "); }
}
public class A{
  static { System.out.println("A Loaded "); }
  public static void main(String[] args){
    System.out.println(" A should have been loaded");
    A1 a1 = null;
    System.out.println(" A1 should not have been loaded");
    System.out.println(a1.i);
  }
}
When you run it you get the output:
A Loaded
 A should have been loaded
 A1 should not have been loaded
A1 Loaded
10
Now, A should be loaded first as you are using its main method. Even though you are doing A1 a1 = null; A1 will not be loaded as it is not yet used (so the JVM figures out that it does not need to load it yet.) When you do a1.i, you are using A1, so before you use it, it must be loaded. That's when A1 is loaded. Finally 10 is printed.
Correct response:
The code will compile without error and will print 6 40 0 30 5 when run.


Question:
1		short s = 10;
2		char c = s;
3		s = c;
Will this compile?

Answer:
Not all short values are valid char values, and neither are all char values valid short values, therefore compiler complains for both the lines 2 and 3. They will require an explicit cast.
A char is a single 16-bit Unicode character. min'\u0000' (or 0) max'\uffff' (or 65,535 inclusive).  A short is a 16-bit signed two's complement integer.min -32,768 max 32,767 (inclusive).
error: possible loss of precision in line 2 and 3.
Another example:
short s = Short.MAX_VALUE; 
char c = s; 
System.out.println( c == Short.MAX_VALUE);
Discussion:
This will not compile because a short VARIABLE can NEVER be assigned to a char without explicit casting. A short CONSTANT can be assigned to a char only if the value fits into a char.

short s = 1; byte b = s; => this will also not compile because although value is small enough to be held by a byte but the Right Hand Side i.e. s is a variable and not a constant.
final short s = 1; byte b = s; => This is fine because s is a constant and the value fits into a byte.
final short s = 200; byte b = s; => This is invalid because although s is a constant but the value does not fit into a byte.

Implicit narrowing occurs only for byte, char, short, and int. Remember that it does not occur for long, float, or double. So, this will not compile: int i = 129L;


Question: What will the output of the following be?
		byte b = (byte)128;
		System.out.println(b);

Answer:
Since the range of a byte is -128 to 127, the cast is necessary to compile and run.  The byte will clock around to the start, which is -128.
The same answer will come from a value of 384.
256 = 0.


*Overloading Methods* -------------------------------------

Question:
Consider the following code:
public class Varargs{
   public void test(){
        test1(10);       //1
        test1(10, 20); //2
   }
   public static void main(String[] args){
     new Varargs().test();
   }
   //insert method here.
}
Which of the following lines can be added independently to the above class so that it will run without any errors or exceptions?
1. public void test1(int i, int j){}
2. public void test1(int i, int... j){}
3. public void test1(int... i){}
4. public void test1(int i...){}
5. public void test1(int[] i){}

Answer:
Even though a var-arg parameter of type int is very similar to int[], they are not interchangeable. Therefore, int[] cannot be substituted for int... and it will not satisfy either of //1 or //2.
An interesting observation is that if you do javap on the following class, you will see the same signature for method m1 and m2. This shows that a var-arg parameter of type T is same as an array of type T.
class TestClass {
    String m1(int[] i) { return ""+i.length; }
    String m2(int... i) { return ""+i.length; }
}
javap TestClass produces this:

    java.lang.String m1(int[]);
    java.lang.String m2(int[]);
Conversely, the following code will not compile:
class TestClass {
    String m1(int[] i) { return ""+i.length; }
    String m1(int... i) { return ""+i.length; }  // Compiler determines that this is a duplicate method.
}
Correct response: 2 & 3.


*Using Loop Constructs* ------------------------------

Question:
What will the following code print?

public class TestClass {
        int x = 5;
        int getX(){ return x; }
        public static void main(String args[]) throws Exception{
            TestClass tc = new TestClass();
            tc.looper();
            System.out.println(tc.x);
        }        
        public void looper(){
            int x = 0;
            while( (x = getX()) != 0 ){
                for(int m = 10; m>=0; m--){
                    x = m;
                }
            }
            
       }     
}

Answer:
Note that looper() declares an automatic variable x, which shadows the instance variable x. So when x = m; is executed, it is the local variable x that is changed not the instance field x. So getX() never returns 0. If you remove int x = 0; from looper(), it will print 0 and end.
Correct response: This program will compile and run but will never terminate.


Question:
Consider the following method which is called with an argument of 7:
public void method1(int i){
   int j = (i*30 - 2)/100;
   POINT1 : for(;j<10; j++){
       boolean flag  = false;
       while(!flag){
			if(Math.random()>0.5) break POINT1;
       }
   }
   while(j>0){
       System.out.println(j--);
       if(j == 4) break POINT1;
   }
}
What will it print? (Assume that Math.random() return a double between 0.0 and 1.0, not including 1.0)

Answer: Remember that a labeled break or continue statement must always exist inside the loop where the label is declared. Here, if(j == 4) break POINT1; is a labelled break that is occurring in the second loop while the label POINT1 is declared for the first loop.
if(j == 4) break POINT1; will cause the following error: undefined label: POINT1.
If this problem is fixed, the output will be: 2, 1.

Question: 
Will the folliwng code print?
public class BreakTest{
  public static void main(String[] args){
    int i = 0, j = 5;
    lab1 : for( ; ; i++){
      for( ; ; --j)  if( i >j ) break lab1;
    }
    System.out.println(" i = "+i+", j = "+j);
  }
}

Answer:
The values of i and j in the inner most for loop change as follows: 
i = 0 j = 5 
i = 0 j = 4 
i = 0 j = 3 
i = 0 j = 2 
i = 0 j = 1 
i = 0 j = 0 
i = 0 j = -1
Note: for ( ; ; --j) actually compiles!
So will for( ; ; )!
(see Test29.java)

Question:
Consider the following code:  
public class Conversion{    
	public static void main(String[] args){      
		int i = 1234567890;      
		float f = i;      
		System.out.println(i - (int)f);    
	} 
}  
What will it print when run?

Answer:
Actually it prints -46. This is because the information was lost during the conversion from type int to type float as values of type float are not precise to nine significant digits. Note: You are not required to know the number of significant digits that can be stored by a float for the exam. However, it is good to know about loss of precision while using float and double.
float f = i;   // f = 1.23456794E9

Question:
Given the following code:
class TestClass{
   public static void main(String args[]){
      int k = 0;
      int m = 0;
      for (int i = 0; i <= 3; i++){
         k++;
         if ( i == 2){
            // line 1
         }
         m++;
      }
      System.out.println( k + ", " + m );
   }
}
What is the output if line 1 is replaces by:
1. break;
2. continue
3. i = m ++;
4. i = 4;

Answer:
This is a simple loop. All you need to do is execute each statement in your head. For example, if line 1 is replaced by break:  
1. k=0, m=0 2. 
iteration 1: i=0     
2.1 k = 1     
2.2 i == 2 is false     
2.3 m = 1 3. 
iteration 2: i = 1     
3.1 k=2     
3.2 i==2 is false     
3.3 m = 2 4. 
iteration 3: i = 2     
4.1 k=3     
4.2 i==2 is true     
4.3 break 5. 
print 3, 2
Correct answers:
1. 3, 2
2. 4, 3
3. 4, 5
4. 3, 3


*Working with methods - Access Modifiers* -------------

Question:
Consider the following code in TestClass.java file:
package p;
private class TC extends java.util.HashMap{
   public TC(){
      super(100);
      System.out.println("TC created");
   }
}
public class TestClass extends TC{
   public TestClass(){
      System.out.println("TestClass created");
   }
   public static void main(String[] args){ new TestClass(); }
}
What will be the output when TestClass is run?

Answer:
The correct answer is that the code will not compile because TC is a top level class and private is not a valid access modifier for a top level class. private can be applied to an inner class.
Error: modifier private not allowed here.


*Java Basics - Garbage Collection* -----------------

Question:
Given the following code:  
class M { } 
class N {    
	private M m = new M();    
	public void makeItNull(M pM){       
		pM = null;    
	}    
	public void makeThisNull(){       
		makeItNull(m);    
	}    
	public static void main(String[] args){       
		N n = new N();       
		n.makeThisNull();    
	} 
}  
Which of the following statements are correct?
1. There are no instances of M to be garbage collected till the program ends.
2. Setting pM = null; in makeItNull(), marks the private instance of M for garbage collection.
3. private members of a class become eligible for garbage collection only when the instance of the class itself becomes eligible for garbage collection.

Answer:
2. pM is just a method parameter (a copy of the original reference) that is passed to makeItNull(). So setting it to null will not affect the original variable.
3. This is not true. Any instance can be made eligible by setting all its references to null. For example, in the following code, the Object instance referred to by 'o', can be made eligible for garbage collection by calling setNull(), even if the instance of X itself is not eligible for garbage collection.

 class X{   
 	Object o = new Object();   
 	public void setNull(){ o = null; } 
 }  
 On the other hand, if the container object becomes eligible for GC and if there are no references to the contained objects outside of the container, the contained objects also become eligible for GC. For example, in the following code, both  - the instance of X and the object instance contained inside X, will become eligible for garbage collection:  
 ... 
 X x = new X(); 
 x = null; 
 ...
Although not mentioned explicitly in the objectives, the exam has a few basic questions on garbage collection.  All you need to know is:
1. An object can be made eligible for garbage collection by making sure there are no references pointing to that object.
2. You cannot directly invoke the garbage collector. You can suggest the JVM to perform garbage collection by calling System.gc();
Correct Answer: 1.


*Using Operators and Decision Constructs* ---------------------

Question:
What, if anything, is wrong with the following code?  
void test(int x){    
	switch(x){       
		case 1:       
		case 2:       
		case 0:       
		default :       
		case 4:    
	} 
}
1. The default statement must go last.
2. There is nothing wrong with the code.

Answer:
1. Any order of case statements is valid.
Correct response: 2.


Question:
Which of the given lines can be inserted at //1 of the following program ?  
public class TestClass{        
	public static void main(String[] args){      
		short s = 9;      //1    
	} 
}
1. int i = 9; System.out.println(s == i);
2. Boolean b = s instanceof Number;
3. Short k = 9; Integer i = 9; System.out.println(k == i);
4. Integer i = 9; System.out.println( s == i );
5. System.out.println(s instanceof Short);
6. Short k = new Short(9); System.out.println(k instanceof Short);

Answer:
1. Any two integral primitives can be compared using == operator.
2. Left operand of instanceof MUST be an object and not a primitive.
3. This will not compile because k and i are referring to objects that have no IS-A relationship among themselves.
5. The left operand of instanceof MUST be an object and not a primitive.
6. 9 is considered an int. This should be: Short s = new Short( (short) 9 );
Correct response: 1 & 4


Question:
What will the following code print ?  
class Test{    
	public static void main(String[] args){       
		int k = 1;       
		int[] a = { 1 };       
		k += (k = 4) * (k + 2);       
		a[0] += (a[0] = 4) * (a[0] + 2);       
		System.out.println( k + " , " + a[0]);    
	} 
}

Answer:
The value 1 of k is saved by the compound assignment operator += before its right-hand operand (k = 4) * (k + 2) is evaluated. Evaluation of this right-hand operand then assigns 4 to k, calculates the value 6 for k + 2, and then multiplies 4 by 6 to get 24. This is added to the saved value 1 to get 25, which is then stored into k by the += operator. An identical analysis applies to the case that uses a[0].   
k += (k = 4) * (k + 2);   
a[0] += (a[0] = 4) * (a[0] + 2);   
k = k + (k = 4) * (k + 2);   
a[0] = a[0] + (a[0] = 4) * (a[0] + 2);
Correct response: 25, 25


Question:
The following code snippet will compile, true of false?:  
int i = 10; System.out.println( i<20 ? out1() : out2() );  
Assume that out1 and out2 have method signature: public void out1(); and public void out2();

Answer:
Note that it is not permitted for either the second or the third operand expression of the ? operator to be an invocation of a void method.
- If one of the operands is of type byte and the other is of type short, then the type of the conditional expression is short.
- If one of the operands is of type T where T is byte, short, or char, and the other operand is a constant expression of type int whose value is representable in type T, then the type of the conditional expression is T.   
- Otherwise, binary numeric promotion (5.6.2) is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands.
- If one of the second and third operands is of the null type and the type of the other is a reference type, then the type of the conditional expression is that reference type.
- If the second and third operands are of different reference types, then it must be possible to convert one of the types to the other type (call this latter type T) by assignment conversion (5.2); the type of the conditional expression is T. It is a compile-time error if neither type is assignment compatible with the other type.
Correct response:  It will not compile.

Question:
Consider the following code snippet:  
XXXX m ; 
//other code   
switch( m ){      
	case 32  : System.out.println("32");   break;      
	case 64  : System.out.println("64");   break;      
	case 128 : System.out.println("128");  break;   
}  
What type can 'm' be of so that the above code compiles and runs as expected ?

Answer:
Three rules must be remembered about switch statement:
1. Only byte, char, short, int, and enum values can be used as types of a switch variable. (Java 7 allows String as well.)
2. The switch variable must be big enough to hold all the case constants.
So, if switch variable is of type char, then none of the case constants can be greater than 65535 because char's range is from 0 to 65535.
3.  All case labels should be COMPILE TIME CONSTANTS.
Correct response: int, char, short.  byte cannot hold 128.

Question:
What letters will be printed by this program?
public class ForSwitch{
    public static void main(String args[]){
        char i;
        LOOP: for (i=0;i<5;i++){
            switch(i++){
                case '0': System.out.println("A");
                case 1: System.out.println("B"); break LOOP;
                case 2: System.out.println("C"); break;
                case 3: System.out.println("D"); break;
                case 4: System.out.println("E");
                case 'E' : System.out.println("F");
            }
        }
    }
}

Answer:
1. Defining i as char doesn't mean that it can only hold characters (a, b, c etc). It is an integral data type which can take any +ive integer value from 0 to 2^16 -1.
2. Integer 0 or 1, 2 etc. is not same as char '0', '1' or '2' etc.
so when i is equal to 0, nothing gets printed and i is incremented to 1 (due to i++ in the switch).
 i is then incremented again by the for loop for next iteration. so i becomes 2.
when i = 2, "C" is printed and i is incremented to 3 (due to i++ in the switch) and then i is incremented to 4 by the for loop so i becomes 4.
when i = 4, "E" is printed and since there is no break, it falls through to case '5' and "F" is printed.
i is incremented to 5 and the for loop ends.
Correct response: C, E, F.
But, bonsider this code:
        int j = 0;
        switch (j++)
        {
        	case 0: System.out.println("j "+j); break;
        	case 1: System.out.println("j "+j); break;
        	default: System.out.println("j "+j); break;
        }
The output for this is: j 1
This indicates that the j++ is applied before the cases are applied.  But in the initial question, if the i++ is applied before the cases, then B would be printed.  This next example shows exactly what is happening:
        int k = 0;
        switch (k++)
        {
        	case 0: System.out.println("k is 0 "+k); break;
        	case 1: System.out.println("k is 1 "+k); break;
        }
The output is: k is 0 1
This means the the switch/case statement is considered as the same line for Java, but the statement after case, the prtinln, is considered the next line, so the variable is incremented.

Question:
Assume that a, b, and c refer to instances of primitive wrapper classes. Which of the following statements are correct?
1. a.equals(a) will always return true.
2. a.equals(b) returns same as a == b.
3. a.equals(b) returns false if they refer to instances of different classes.

Answer:
2. The wrapper classes's equals() method overrides Object's equals() method to compare the actual value instead of the reference.
Equals method of a primitive wrapper class ( e.g. java.lang.Integer, Double, Float etc) are 1. symmetric => a.equals(b) returns same as b.equals(a) 2. transitive => if a.equals(b) and b.equals(c) return true, then a.equals(c) returns true. 3. reflexive => a.equals(a) return true.  For example, the following code for the equals method on Integer explains how it works: public boolean equals(Object obj) {    if (obj instanceof Integer) {        return value == ((Integer)obj).intValue();    }    return false; }
Correct response: 1 & 3.


Question:
Consider the following lines of code:  
Integer i = new Integer(42); 
Long ln = new Long(42); 
Double d = new Double(42.0);  
Which of the following options are valid?
i == ln; // 1
ln == d; // 2
i.equals(d); // 3
d.equals(ln); // 4
ln.equals(42); // 5

Answer:
The concept to understand here is as follows -
If the compiler can figure out that something can NEVER happen, then it flags an error. In this question, the compiler knows that ln, i or d can never point to the same object in any case because they are references to different classes of objects that have no relation ( superclass/subclass ) between themselves.
Therefore 1 and 2 will fail at compile time.
5. Due to auto-boxing int 42 is converted into an Integer object containing 42. So this is valid. It will return false though because ln is a Long and 42 is boxed into an Integer.
Correct response: 3, 4, 5.

Question:
What is the result of executing the following fragment of code:  boolean b1 = false; 
boolean b2 = false; 
if (b2 != b1 = !b2){    
	System.out.println("true"); 
} else{    
	System.out.println("false"); 
}

Answer:
Note that  boolean operators have more precedence than =. (In fact, = has least precedence of all operators.) so, in (b2 != b1 = !b2)  first b2 != b1 is evaluated which returns a value 'false'. So the expression becomes false = !b2. And this is illegal because false is a value and not a variable!
Had it been something like (b2 = b1 != b2) then it is valid because it will boil down to : b2 = false.  Because all an if() needs is a boolean, now b1 != b2 returns false which is a boolean and as b2 = false is an expression and every expression has a return value (which is actually the Left Hand Side of the expression). Here, it returns false, which is again a boolean.
Note that return value of expression :  i = 10 , where i is an int, is 10 (an int).
Correct response: compile time error.


*Creating and Using Arrays* --------------------------------------

Question: 
Which of the following code fragments will successfully initialize a two-dimensional array of chars named cA with a size such that cA[2][3] refers to a valid element?  
1.   char[][] cA = {  { 'a', 'b', 'c' },  { 'a', 'b', 'c' }   }; 
2.   char cA[][] = new char[3][];   
	for (int i=0; i<cA.length; i++) cA[i] = new char[4]; 
3.   char cA[][] = { new char[ ]{ 'a', 'b', 'c' }  ,   new char[ ]{ 'a', 'b', 'c' }  }; 
4    char cA[3][2] = new char[][] {  { 'a', 'b', 'c' },   { 'a', 'b', 'c' }   }; 
5.   char[][] cA = { "1234", "1234",  "1234"  };

Answer:
1 and 3 declare a two dimensional array alright but they create the array of size 2, 3. And cA[2][3] means we need an array of
size 3, 4 because the numbering starts from 0.
4 : You cannot put array size information on LHS.
5 : This is a one dimensional array and that too of strings. Note that a java String is not equivalent to 1 dimensional array of chars.
This leaves us with only one choice 2.


Question:
What will the following program print?
class Test{
   public static void main(String[] args){
      int i = 4;
      int ia[][][] = new int[i][i = 3][i];
      System.out.println( ia.length + ", " + ia[0].length+", "+ ia[0][0].length);
   }
}

Answer:
In an array creation expression, there may be one or more dimension expressions, each within brackets. Each dimension expression is fully evaluated before any part of any dimension expression to its right. The first dimension is calculated as 4 before the second dimension expression sets 'i' to 3.
Note that if evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated.
Correct response: 4,3,3

Question:
What will be the result when the following code is run?
class Test26 {
	public static int[ ] getArray() {return null;}
	public static void main(String[] args) {
		int index = 1;
		try {
			getArray()[index=2]++;
		} catch (Exception e){ } //empty catch
		System.out.println("index = " + index);
	}
}

Answer:
If the array reference expression produces null instead of a reference to an array, then a NullPointerException is thrown at runtime, but only after all parts of the array reference expression have been evaluated and only if these evaluations completed normally. 
This means, first index = 2 will be executed, which assigns 2 to index. After that null[2] is executed, which throws a NullPointerException. But this exception is caught by the catch block, which prints nothing. So it seems like NullPointerException is not thrown but it actually is.
In other words, the embedded assignment of 2 to index occurs before the check for array reference produced by getArray().
In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated. Note that if evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated.
Correct response: index = 2

Question:
Which of the following is a benefit of ArrayList over an array, true or false?
It allows you to write type safe code.

Answer:
Since ArrayList is a generics enabled class, it helps you write type safe code. For example, if you have:   ArrayList<String> al = new ArrayList<>(); al.add(new Integer(10)); will not compile because the compiler knows that al can only contain Strings.  However, this is not an advantage over an array because arrays are also type safe. For example, if you have: String[] sa = new String[10]; you cannot do sa[0] = new Integer(10); either.  But you can do Object[] oa = sa; and oa[0]  = new Integer(10); This will compile fine but will fail at runtime. This is a hole in the type safety provided by arrays.
Correct Answer: false.


*Bunus Material!* ----------------------------------------------

Question:
String s1 = "Rakesh";
String s2 = "Rakesh";
String s3 = "Rakesh".intern();
String s4 = new String("Rakesh");
String s5 = new String("Rakesh").intern();
if ( s1 == s2 ){System.out.println("s1 and s2 are same");}
if ( s1 == s3 ){System.out.println("s1 and s3 are same" );}
if ( s1 == s4 ){System.out.println("s1 and s4 are same" );}
if ( s1 == s5 ){System.out.println("s1 and s5 are same" );}

Answer:
public String intern()
Returns a canonical representation for the string object.
A pool of strings, initially empty, is maintained privately by the class String.
When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
All literal strings and string-valued constant expressions are interned. String literals are defined in 3.10.5 of the Java Language Specification
Returns:
a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.
Correct response:
s1 and s2 are same
s1 and s3 are same
s1 and s5 are same

There is a no difference for args whether it is defined as String[] args or String args[]. However, there is an important difference in the way it is defined as illustrated by the following:  
1. String[] sa1, sa2; Here, both - sa1 and sa2 are String arrays.  
2. String sa1[], sa2; Here, only sa1 is a String array. sa2 is just a String.

Question:
Given the following LOCs:     
int rate = 10;    
XXX amount = 1 - rate/100*1 - rate/100;  
What can XXX be?

Answer:
Note that none of the terms in the expression 1 - rate/100*1 - rate/100; is double or float. They are all ints. So the result of the expression will be an int. Since an int can be assigned to a variable of type int, long, float or double, amount cAn integer can be assigned to a double but not vice versa.

Object class's equals() method just checks whether the two references are pointing to the same location or not.

When refactoring a class to make it better in terms of encapsulation, the key is that your data variable should be private and the functionality that is to be exposed outside should be public. Further, your setter methods should be coded such that they don't leave the data members inconsistent with each other.
an be int, long, float or double.
Correct response: int, long, float or double

An integer can be assigned to a double but not vice versa.
A byte can ALWAYS be assigned to an int.
a short or byte cannot be assigned to each other unless they are cast:
		short s = 10;
		char c = s; // error
		s = c;      // error
final short s = 1; byte b = s; => This is fine because s is a constant and the value fits into a byte.
Implicit narrowing occurs only for byte, char, short, and int. Remember that it does not occur for long, float, or double. So, this will not compile: int i = 129L;

Object class's equals() method just checks whether the two references are pointing to the same location or not.

When refactoring a class to make it better in terms of encapsulation, the key is that your data variable should be private and the functionality that is to be exposed outside should be public. Further, your setter methods should be coded such that they don't leave the data members inconsistent with each other.

