Question Types

Inheritance
Integer
Doubles & Floats
Numbers
Arrays
Interface & Abstract Classes
Extending a Class
Strings
Booleans
Rules of Promotion
Inner Classes
Overriding & Hiding
Math
Access
Primitives
Looping
Methods
Overloading
The Object Class
Exceptions
The List Class
The euqals Method
The == Operator
The instanceof Operator
Reserved Words
The toArray method
IO
Regex
Initial Capacity
Printf
Pass by Reference
Enum
Random


**Inheritance** /*----------------------------------------

- constructors are not inherited

How do you hide an inherited method?  It's considered a bad programming practice, but the table in Overriding and Hiding Methods section shows the effect of declaring a method with the same signature as a method in the superclass.
						 Superclass Instance Method		Superclass Static Method
Subclass Instance Method Overrides						compile-time error
Subclass Static Method	 compile-time error				Hides

Question:
Which set of statements result in ClassB and ClassC being derived
from ClassA?
a. class ClassB extends ClassA {}
b. class ClassB extends ClassC {}
c. class ClassA extends ClassB {}
d. class ClassC extends ClassB {}
e. No combination will work

Answer: a and d This results in ClassC being the "grandchild" of ClassA.

**Integers** /*-------------------------------------
Question:
What Integer method would you use to convert a string expressed in base 5 into the equivalent int? For example, how would you convert the string "230" into the integer value 65? Show the code you would use to accomplish this task.

Answer:
String base5String = "230";
int result = Integer.valueOf(base5String, 5);
static Integer valueOf(String s, int radix): Returns an Integer object holding the value extracted from the specified String when parsed with the radix given by the second argument.

43 = o53 (octal)

Integer n1 = new Integer(0);
Byte n2 = new Byte((byte)0);
System.out.println(n1.equals(n2)); false!!!

Integer num_123 = Integer.parseInt("123L");
- this method accepts digits only and causes a runtime exception
Integer num_123 = Integer.parseInt(123L);
- compile time error: no suitable method.
parseInt(long)
Integer num_123L = Integer.parseInt(123);
- same error, no method parseInt(int)


**Doubles & Floats** /*---------------------------------------

Question: What Double(Float) method can you use to detect whether a floating-point number has the special value Not a Number (NaN)?

Answer: 
isNaN()
NaN	Example
	Double d1 = new Double(-1.0/0.0);
	Double d2 = new Double(0.0/0.0);
     // returns true if this Double value is a Not-a-Number (NaN) 
     System.out.println(d1 + " = " + d1.isNaN()); // false
     System.out.println(d2 + " = " + d2.isNaN()); // true

		Byte b1 = 1;
		byte b2 = 1;
		System.out.println((b1==b2)); // true
		double num1 = 0.2;
		float num2 = 0.2f;
		System.out.println(num1+" == "+num2);
		System.out.println(num1 == num2); // false
		System.out.println(num1 == (double)num2); // false
		System.out.println((float)num1 == num2); // true
		num1 = 0.5;
		num2 = 0.5f;
		System.out.println(num1+" == "+num2);
		System.out.println(num1 == num2); // true
		System.out.println(num1 == (double)num2); // true
		System.out.println((float)num1 == num2); // true

Question:
float x = 0.1f;
while (x != 1.1) 
{
	System.out.printf("x = %f%n", x);
	x = x + 0.1f;
}

Answer:
The number 0.1 cannot be stored precisely in base two in the same way that the
decimal equivalent of the fraction 1/3 cannot be represented exactly (0.333333â€¦).  The result of adding this number repeatedly to x will result in a number that is not quite 1.1. The comparison, x != 1.1, will return true and the loop will never end.  The output of the printf statement does not show this difference:
...
x = 0.900000
x = 1.000000
x = 1.100000
x = 1.200000
x = 1.300000
...


**Numbers** --------------------------------------------------

		Integer num3 = 123;
		float num4 = 123.0f;
		double num5 = 123.0;
		float num6 = 123;
		Integer num7 = new Integer("123");
		byte num8 = 123;
		System.out.println("Integer == float "+(num3 == num4)); //true
		System.out.println("double == float "+(num5 == num4));  // true
		System.out.println("float == int "+(num6 == num7));     // true
		System.out.println("int == byte? "+(num7 == num8));     // true

Integer numm1 = 0;
Float numm2 = -0.0F;
(numm1.intValue() == numm2)) true
Float numm3 = 0.0F;
(numm1.intValue() == numm3)) true



**Arrays** /*-------------------------------------------------

Question:
int []a = {1,2,3,4,5,6};
ini i = a.length -1;
while(i>=0)
{System.out.println(a[i]);i--;}

Answer:
What is the output?
Result 654321
length is 6, so i is set to 5. go from index 5 to 0, which means 6 to 1 will be printed.  If we use (i>0) instead, the output is from 6 to 2.

Question:
int a[] = {1,2,3,4}
print(a instanceof Object) 

Answer:
Arrays are objects, so prints true.

Question:
int a[][] = new int[3][];
a[1]=new int[]{1,2,3};
a[2]=new int[]{4,5};
print(a[1][1]);

Answer:
Compiles and prints 2.

Question: Which of the following statements will compile without an error?
a. int arr[];
b. int arr[5];
c. int arr[5] = {1,2,3,4,5};
d. int arr[] = {1,2,3,4,5};
The number of elements in an array declaration is not used in
the declaration. However, we can use the following:
int arr[] = new int[5];

Answer: 
a and d


// question 20
		Integer arr[] = {2,1,0};
		print(arr);
		...
		public static void print(int...arr)
- Though Integer can be boxed into int type, Integer[] cannot be boxed to int[], so
print(int...arr) cannot be applied to print(Integer[]). and causes a compiler error


Question:
Given the following code, which of the following statements can be used to
determine if cat can be found in the list?
ArrayList<String> list = new ArrayList<>();
list.add("dog");
list.add("cat");
list.add("frog");
a. list.contains("cat")
b. list.hasObject("cat")
c. list.indexOf("cat")
d. list.indexOf(1)

Answer:    
a and c The contains method will return true if the object is found
and indexOf takes an object reference and returns the index
of the object if found, otherwise it returns a -1. The indexOf
method does not take an integer argument and the hasObject
method does not exist.

Question:
Given the Customer is a class:
1. Customer []c1 = new Customer[10];
2. Customer [][]c2 = new Customer[10][];
3. c2[0] = new Customer[5];
4. print(c1[0]); // prints null
5. print(c2[1][0]); 

Answer:
In the case of arrays, initialization is supposed to be complete when we specify the leftmost dimension of the array.  The problem occurs at runtime if we try to access an element of the array which has not been initialized (specification of size).  In the question above there is no problem until line 5.  We are tyring to access c2[1][0] whereas we have only initialized c2[0].  In other words we can access any element in c2[0] row but not any other element which is in any row other than c2[0].  Therefore accessing c2[1][0] will cause a runtime exception (npe).




**Interface & Abstract Classes** /*----------------------*/

- Must extend an abstract class
- An interface can't extend a class
- classes cannot extend interfaces, they must implement them.
- An interface can extend multiple interfaces
- The method definitions inside interfaces are public and abstract. They cannot be private or protected.

A variable from an interface is by default final so cannot be changed in a subclass.
- Interfaces only describe behaviour, not state.
- they're only to be used as constants. Hence static and final. 

- abstract classes cannot be instantiated

-  abstract methods cannot define a method body.
public abstract void method(){}
final abstract int method(){}
- both are illegal.  it should be like this:
public abstract void method();

Question:
interface IAccount { String getAccoundNumber();}
abstract class Account implements IAccount{}

Answer:
The class Account is valid as it is declared abstract and therefore doesn't have to implement all the methods of the superclass.

- Watch out!!! You cannot assign a value to a variable declared in an interface even when the class at hand implements that interface, as all interface variables are implicitly final!

- You can only implement interfaces:
class Outside implements String // interface expected


**Extending a Class** a.k.a. Polymorphism -------------------------

Left Side vs. Right Side
	A a 		 =  	new B()
Reference Side   / Instance side
Reference handle / assigned to class type
declared as      / actual insance
Static methods   / instance methods
compile time     / runtime polymorphism (late binding)
hides (static)   / overrides

Question:
- Basic Example:
class Base
{
	int i = 99;
	public void amethod()
	{
		System.out.println("Base.amethod");
	}
	Base()
	{
		amethod();
	}
}
public class Derived extends Base
{
	int i = -1;
	public static void main(String argv[])
	{
		Base b = new Derived();
		System.out.println(b.i);
		b.amethod();
	}
	public void amethod()
	{
		System.out.println("Derived.amethod()");
	}
}

Answer:
Output: 
Derived.amethod()
99
Derived.amethod()
- This creates an instance of the Derived class but assigns it to a reference of the Base class.  In this situation a reference to any of the fields such as i will refer to the value in the Base class, but a call to a method will refer to the method in the class type rather than its reference handle.  But note that if the amethod() was not present in the base class, then compilation error would be reported at compile time.  When the compiler sees the statement like b.amethod(), it checks if the method is present in the Base class or not.  Only at the run time does it decide to call the method from the derived class.

Question:
class Parent
{
	private void method1(){System.out.println("Parent1");}
	public void method2(){System.out.println("Parent2"); method1();}
}
class Child extends Parent
{
	public void method1()
	{System.out.println("Child1");}
	 public static void main(String args[])
	 {Parent p = new Child();p.method2();}
}

Answer:
Output: 
Parent2
Parent1
If method1 in parent were not private, the output would be:
Parent2
Child1

Question:
Given the following class definitions:
public class ClassA 
{
	public ClassA() 
	{
		System.out.println("ClassA constructor");
	}
	public void someMethod() 
	{
		System.out.println("ClassA someMethod");
	}
}
class ClassB extends ClassA 
{
	public ClassB() 
	{
		System.out.println("ClassB constructor");
	}
	public void someMethod() 
	{
		// comment
		System.out.println("ClassB someMethod");
	}
	public static void main(String args[]) 
	{
		ClassB b = new ClassB();
		b.someMethod();
	}
}

Answer:
What statement is needed at the comment line to generate the
following output:
ClassA constructor
ClassB constructor
ClassA someMethod
ClassB someMethod
a. super();
b. super().someMethod;
c. super.someMethod();
d. someMethod();
e. None of the above
c (second time lucky!)
The first answer is used only as the first statement of a
constructor. The second answer generates a syntax error. The
fourth option results in unbounded recursion.  Therefore the correct answer is c.


Question:
class Bank
{
	String bankName;
	public String getBranchName()
	{
		return bankName;
	}
}
public class BankBranch extends Bank
{
	public static void main(String[] argv) {}
	public String getBranchName() throws Exception 
	{
		return bankName;
	}
}

Answer:
Does not compile: getBranchName() cannot override the superclass method.  The overridden method does not throw an exception.  (But it could if it were a RuntimeException, right?  Or is that only checked exceptions?)

Question: if A extends B,
A a = new A();
B b = new B(); 
which are legal?
b=a 	
b=(A)a; 
a=b;
a=(A)b;
a=(B)b;

Answer: 
The first two are not legal.

Question:
interface Rideable 
{
	String getGait();
}
public class Camel implements Rideable 
{
	int weight = 2;
	public static void main(String[] args) 
	{
		new Camel().go(8);
	}
	void go(int speed) 
	{
		++speed;
		weight++;
		int walkrate = speed * weight;
		System.out.print(walkrate + getGait());
	}
	String getGait() 
	{
		return " mph, lope";
	}
}

Answer:
error: getGait() in Camel cannot implement getGait() in Rideable
attempting to assign weaker access privileges; was public
- This happens becuase "methods in an interface are implicitly public, so the public modifier can be omitted." but the default for a class is package private.

class A.  class B extends A.
A a = new B().go() output: B
B b = new A() compile error- incompatible types: required: A found: B 

//package java.lang;
public class ExtendedObject extends java.lang.Object
{
		String name = "DEFAULT VALUE";
		protected void finalize() { name = null; }
		public static void main(String as[]) throws Throwable
		{
			Object ob = new ExtendedObject();
			ob.finalize();
			System.out.println(ob);
		}
}

a. the code will not compile.
b. by uncommenting line 1, it will compile.

The finalize() method is declared as protected in the class Object, so it cannot be invoked from code in other packages.  The compile error msg says finalize() has protected access in java.lang.Object
If we use the same package java.lang then the code will compile, but at runtime a SecurityException will be thrown stating that prohibited package name:java.lang.
When we ran the class with the uncommented package line, we got a java.lang.NoClassDefFoundError runtime error.
The same behavior would be found if we eliminate the extends part.  Here is some discussion about that.
"Unless the Object class is not actually the java.lang.Object class (the tutorial does not include the imports, so it's hard to see), the extends Object is redundant."
"Extends clause is optional as stated in Java Language Specification. If it is omitted, the class is derived from java.lang.Object. It is just a matter of coding style to write it or not to write it in this case. Usually it is omitted."


Question: Consider the following code:
class Base {
	int i = 1999;
	public void aMethod() {System.out.println("Base.amethod()");}
	Base() {aMethod();}
}
public class Derived extends Base {
	int i = -1;
	public static void main(String[] args) {
		Base b = new Derived();
		System.out.println(b.i);
		b.aMethod();
	}
	public void aMethod(){System.out.println("Derived.aMethod()");}
}

Answer:
It creates an instance of the Derived class but assignes it to a reference of the Base class.  In this situation a reference to any of the fields such as i will refer to the value in the Base class, but a call to a method will refer to the method in the class type rather than its reference handle.
But note that if the aMethod was not present in the base class then compilation error would be reported at compile time, when the compiler sees the statement b.aMethod(), it checks if the method is present in the bass class.  Only at runtime it decides to call the method from the derived class.
The constructor in Base is called when the new Derived object is created, but the call in the constructor calls the method is the subclass, since it is present.
Output:? 
Derived.aMethod()
1999
Derived.aMethod()

Question:
class C extends A {public C() {System.out.println("C");}}
class A { public A(){System.out.println("A");}}
class B extends C {public B(){System.out.println("B");}}
public class Test17 {
	public static void main(String[] args) {
			System.out.println("Test17");
			B c = new B();
		}	
}
Output: ACB
class A { public A(){System.out.println("A");}}
class B extends A {public B() {System.out.println("B");}}
class C extends B {public C(){System.out.println("C");}}
public class Test17 {
	public static void main(String[] args) {
			System.out.println("Test17");
			C c = new C();
		}	
}
Output: ACB
The contruction order is from bottom to up (who wrote this shit?) from each child class constructor its parent's constructor will be called and so on till the topmost class in he hierarchy.
Actually I would say it is from the top to the bottom.  The top of the heirachy is A, then down to its child, and then its child.  That's just the way it looks to me.  We might have gotten this question right but we skipped it due to its lenght and lack of time.




**Strings** /* ---------------------------------------

Question:
String s = "Java";
s.concat(" SE 6");
s.replace('6','7');

Answer:
print(s) 
Output:
Java 
(the two calls are abandoned instantly)

- How many objects are created?
line 3, two more objects created, 'SE 6', and 'Java SE 6'
line 5 'java'
3. String s = "Java"; 1
4. s.concat(" SE 6"); 2,3
5. s.toLowerCase();   4


**Booleans** -------------------------------------------

Any string other than 'true' of 'false' as a Boolean constructor will result in a value of false;  Note case does not matter.
boolean a = new Boolean("tRuE"); will allocate a Boolean object representing true.

Question:
		Boolean string1=new Boolean("TrUe");
		boolean character1=true;
		System.out.println(string1.booleanValue()==character1); // 1
		System.out.println(string1==character1);				// 2
		System.out.println(string1.equals(character1));			// 3
		System.out.println(string1.booleanValue()=="true"); 	// 4
		System.out.println(string1.equals("true"));				// 5
		System.out.println(character1=="true"); 				// 6
What is the output?

Answer: 
Compile error: incompatible types, boolean and String
For lines 4 and 6.


**Rules of Promotion** ---------------------------------

Question:
int num = -50;
System.out.println(num % 25.0)

Answer:
output -0.0
We suppose that any expression containing a negative will give a negative answer, as well as follow the rules of promotion.

Question:
int a = 5;
print("Value is - "+((a < 5) ? 9.9 : 9));

Answer:
The result of a ternary operator must be determined at compile time, and here the type chosen using the rules of promotion for binary operands is double.  Since the result is a double the output value is printed in a floating point.  The choice of which value to be printed is made on the basis of the result of the comparison "a < 5" which results in false, hence the variable "a" takes the second of the two possible values, which is 9, but because the result type is promoted to double the output value is actually written as 9.0 rather than the more obvious 9.

- if the unary operators + and - are applied to byte, char or short the types are automatically promoted to an int.

Question: Which method will be called:
void aMethod(Object ob) { //1 }
void aMethod(Float ob) {  //2 }
...
test.aMethod(0.0);

Answer:  
0.0 is autoboxed to Double object.  Following the rules of promotion:
int long float double, why isn't the wrapper class used?  Lets look at another question:

public class AccountBal
{
	public int getBalance(Short amt){return amt*2;}
	public double getBalance(double amt){return amt*3;}
	//public long getBalance(long amt){return amt*4;}
	public static void main(String[] args) {
		AccountBal ac = new AccountBal();
		Integer val = 20;
		System.out.println(ac.getBalance(val));
	}
}
Our choice was:
1 code will not compile
2 if you uncomment the long method, the code will compile, run and print 80.
The lab answer said the code will comple, run and print 60.0
The lab notes state: The getBalance() call made from the main method with an int argument calls the getBalace(double amt) method and prints 60.0.  Because short cannot hold an int.  If we uncomment getBalance(long amt) method then the getBalance(double amt) will not be called and hence 80 will be printed out.
Is this a rules of promotion thing?  With an Integer, what other types will work?
int fits with double
That's Integer actually.
float only goes to float.
 float will not fit into a Float, but a double.  
 If we cancel out the double, then it will fit into the Float method.
 float to float, double, Float, end.
 Float Float, float, double, end.
 int to int, long, float, double, Integer, end.
 Integer to Integer, int, long, float, double, end
 byte to byte, short, int, long, float, double, Byte, end.
 Byte to Byte, byte, short, int...
 char to char, int, long, float, double, Character, end.
 Character to Character, char, int, long, float, double, end.
 short to short, int, long, float, double, Short, end.
 Short to Short, short, int, long, float, double, end.
 float double Float end.
 long to long, float, double, Long, end.
That's the opposite to the rules of promotion, which we had as double, float, long, int.  So the order for primitives is:
int
long
float
double
Wrapper class.
For a wrapper class, it slips that last step.

Now back to the previous question:
aMethod(0.0);
This will call a method that accepts a double, Double, Object, but never a Float.  A compile time error would occur first.
If we try this:
aMethod(0.0f);
The order is float, double, Float, Object compile error.  Never will it call the Double method.  Strange.
aMethod(-0.0); double, Double, Object, error
aMethod(0); // int, long, float, double, Integer, Object, error
Remember, a byte has the following order:
byte, short, int, long, float, double, Byte.
What if we throw a string in there?
aMethod("0"); // String, Object, error.


**Inner Classes** ---------------------------------------

- An inner class can be delcared public, final, abstract.
- A local (inner) class can have static members provided that they are constant variables.

What is true about local inner classes?
- They can access only final variables.

- Nested (inner) classes can be declared abstract, final, private, public, or protected to restrict access to the class.



Questions 27
public class TestInterface
{
	public abstract class InnerTest
	{
		abstract void f();
	}

	public static void main(String[] args) {
		TestInterface t = new TestInterface();
		//t.f(); // cannot be found
		TestInterface.InnerTest test = t.new InnerTest()
		{
			public void f() 
			{ 
				System.out.println("Inner f");
			}
		};
		test.f(); 
	}
}

Answer:
Works fine.


public class Outer {
	public int a = 1;
	privte int b = 2;
	public void method(final int c)
	{
		int d = 3;
		class inner
		{
			private void iMethod(int e)
			{
				// which variables may be referenced here?
			}
		}
	}
}

Since inner is not a static inner class, it has a reference to an enclosing object and all the variables of that object are accessible. Therefore a and b are correct even if b is private. Variables in the enclosing method are only accessible when they are marked as final, hence c is accessible but not d. e is obviously correct as it is a parameter to the method containing line 12 itself.  d is not final so not visible.  So a, b, c and e are correct.

Question:
class TestOuter
{
	static Integer num = 200;
	TestOuter()
	{
		num = 400;
	}
	static class TestInner
	{
		TestInner()
		{
			System.out.print(num);
		}
	}
	public static void main(String[] args) {
		new TestOuter.TestInner();
	}
}

Answer:
What will be printed?  Static nested classes are allowed to access static variables of the enclosing class.  So 200 will be printed.  The OuterClass is never instantiated, so the value is not changed by the constructor.  If we put this before the call, TestOuter to = new TestOuter();, 400 will be printed.


**Overriding & Hiding** -------------------------------------

- an overriding method can allow more, but not less, access than the overridden method. Order: public, protected, (no modifier), private

- An overriding method must not throw any checked exceptions that were not declared in the original method.

Question
Which of the following must be true for a method to support polymorphism?
a. The method must override a base class method
b. The method must overload a base class method
c. The method's class must extend a base class that has the
overridden method
d. The method must execute against a base class reference variable

Answer: 
Overloading only occurs within the same class. It is not necessary to have a base class. A common implemented interface will also work for polymorphic behavior. So a and d are correct.

If a method declararation overrides a method in the super class, there will be a compile time error when:
- there are different return types
- one is void and the other has a return type
- one throws a clause that conflicts with that of any other method that it overrides or hides
However, it can throw unchecked exceptions (RuntimeExceptions and it's descendants)  

Given this:
	public class Customer
	{
    	double calculate(int num) { /* */ }
	}
You can do this in a subclass:
	double calculate(int num)
	public double calculate(int num)
	protected double calculate(int num)
	double calculate(int num) throws RuntimeException
You cannot do these:
	double calculate(int num) throws Exception
	private double calculate(int num)


**Math** ------------------------------------------------

Question:  What is the return type of method round(double d) defined in Math class?

Answer: 
long 

static long	round(double a): Returns the closest long to the argument, with ties rounding up.
static int	round(float a): Returns the closest int to the argument, with ties rounding up.


**Access** -----------------------------------------

Question:
Which of the following keywords cannot be used when declaring a class?
a. public  
b. private 
c. protected 
d. package   

Answer:
a and b Only the private and public keywords can be used when
declaring a class and the private keyword can only be used
with inner classes.

Question:
Assuming that the following classes are in the same package, which
statements are true?
class SomeClass 
{
	void method1() { }
	public void method2() { }
	private void method3() { }
	protected void method4() { }
}
public class SomeClassAccessDemo 
{
	public void someMethod(String[] parameters) 
	{
		SomeClass sc = new SomeClass();
		sc.method1();
		sc.method2();
		sc.method3(); // only private methods are not visible.
		sc.method4();
	}
}
a. sc.method1() will generate a syntax error.
b. sc.method2() will generate a syntax error.
c. sc.method3() will generate a syntax error.
d. sc.method4() will generate a syntax error.
e. No syntax errors will be generated.
c As the classes are in the same package and all of the methods
are visible except for the private method.


Questions:
package packages;
public class Account { protected String number = "123"; }
import packages.*;
public class SilverAccount extends Account
{
	public static void main(String[] args) {
		Account gold = new Account();
		// System.out.println(gold.number); // call 1
		SilverAccount silver = new SilverAccount();
		System.out.println(silver.number); } // call 2
}

Answer:
Protected variables or methods will not be accessable by a sub-class from their parent classes which are in different packages.  
call 1<- protected access!
call 2 works with the subclass.	


Question:
public int aMethod(String a)
{
	private int b = a;
	return b;
}

Answer:
local variables can be declared as final and cannot be declared static private, public or protected.  Local variables are defined in the bodies of methods.  Trying to use any declaration besides static will cause a compile error that says: illegal start of expression

**Primitives** ---------------------------------------------

float f=3.1415; float f = 3.14f;

byte b=257; wrong!!!
A byte has the range of -128 to 127 only.


**Looping** -----------------------------------------

Given the following declarations, which of the following statement will
compile?
int i = 5;
int j = 10;
a. while(i < j) {}
b. while(i) {}
c. while(i = 5) {}  thought it was i == 5!
d. while((i = 12)!=5) {}  // (12 != 5)

a and d The other options will not work because the expression does
not evaluate to a Boolean value.

Given the following declaration of an array, which statement will display
each element of the array?
int arr[] = {1,2,3,4,5};
a. for(int n : arr[]) { System.out.println(n); }
b. for(int n : arr) { System.out.println(n); }
c. for(int n=1; n < 6; n++) { System.out.println(arr[n]);
}
d. for(int n=1; n <= 5; n++) { System.out.println(arr[n]);
}
b,c,d are correct.
No, they aren't!  only b is correct. c  misses the first element, and d causes an array index out of bounds exception!


**Methods** ------------------------------

Question:
Which of the following declares a method that takes a float and an integer and returns an array of integers?
a. public int[] someMethod(int i, float f)
{ return new int[5];}
b. public int[] someMethod(int i, float f)
{ return new int[];}
c. public int[] someMethod(int i, float f)
{ return new int[i];}
d. public int []someMethod(int i, float f)
{ return new int[5];}

Answer:
a, c, and d Option b fails to initialize the array properly.


**Overloading** ----------------------------------

Question:
Which of the following statements about overloaded methods are true?
a. Static methods cannot be overloaded.
b. The return value is not considered when overloading a method.
c. Private methods cannot be overloaded.
d. An overloaded method cannot throw exceptions.

Answer:
- a The return value is not considered when overloading a method so b is the correct answer.

Question:
Given the following code, which of the following statements are true?
public class SomeClass {
public SomeClass(int i, float f) { }
public SomeClass(float f, int i) { }
public SomeClass(float f) { }
public void SomeClass() { }}
a. error will occur cause void cannot be used with a constructor.
b. error will occur cause the first two constructors are not unique.
c. The class does not have a default constructor.
d. No syntax errors will be generated.

Answer: 
The last line is a method that happens to have the same name as the constructor. As there are constructors defined but no
default constructor, the class has no default constructor.  So c and d are correct.


**The Object Class** ----------------------------------------

What method is used to determine the type of an object?
a. isType
b. typeOf
c. instanceof
d. instanceOf

Answer: 
d The other methods do not exist.
We beg to differ.  instanceof is an operator.  The method would be getClass and then use instancof?  Pretty sure they mean c., which then makes the question's use of the word 'method' wrong.


**Exceptions** --------------------------------------------

- checked exceptions represent invalid conditions in areas outside the immediate control of the program.

Question:
1. Which of the following implement checked exceptions?
a. Class A extends RuntimeException
b. Class A extends Throwable
c. Class A extends Exception
d. Class A extends IOException

Answer: 
Checked exceptions are those classes that extend the Exception class but not the RuntimeException class.  So the answer is c and d.

Question:
What exceptions may the following code generate at runtime?
String s;
int i = 5;
try{
	i = i/0;
	s += "next";
}
a. ArithmeticException
b. DivisionByZeroException
c. FileNotFoundException
d. NullPointerException

Answer:
DivisionByZeroException does not exist. No file
operations are performed here.  So the answer is a and d.

Question:
BufferedReader reader = null;  Â Â Â Â 
try { Â Â Â Â Â Â Â Â 
	URL url = new URL("www.epractizelabs.com/serverdate.html");		
	reader = new BufferedReader(new InputStreamReader(url.openStream()));
	String line = reader.readLine(); Â Â Â Â Â Â Â Â 
	SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");Â Â Â Â Â Â Â Â 
	Date date = format.parse(line); Â Â Â Â 
} catch (MalformedURLException exception) 
{  Â Â Â Â Â Â Â Â // handle wrong URL Â Â Â Â 
} catch (IOException exception) 
{  Â Â Â Â Â Â Â Â // handle I/O errors Â Â Â Â 
} catch (ParseException exception) 
{  Â Â Â Â Â Â Â Â // handle date parse problems. Â Â Â Â 
} finally 
{  Â Â Â Â Â Â Â Â 
	if (reader != null) 
	{ Â Â Â Â Â Â Â Â Â Â Â Â 
		try 
		{ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
			reader.close(); Â Â Â Â Â Â Â Â Â Â Â Â 
		} catch (IOException ex) 
		{ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
			ex.printStackTrace(); Â Â Â Â Â Â Â Â Â Â Â Â 
		}  Â Â Â Â Â Â Â Â 
	} Â Â Â Â 
}

Question : Which of the following Java SE 7 code snippets replaces above code?

Select one. 
Choice A:Â 
try { Â Â Â Â 
	BufferedReader reader = new BufferedReader(new InputStreamReader( new URL("http://www.epractizelabs.com/serverdate.html").openStream())); Â Â Â Â 
	String line = reader.readLine(); Â Â Â Â 
	SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");Â Â Â Â 
	Date date = format.parse(line); } catch (ParseException | IOException exception) {  Â Â Â Â // handle I/O problems. } 

Choice B:
try (BufferedReader reader = new BufferedReader(new InputStreamReader(new URL Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ("www.epractizelabs.com/serverdate.html").openStream()))) { Â Â Â Â String line = reader.readLine(); Â Â Â Â SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY"); Â Â Â Â Date date = format.parse(line); } catch (ParseException | IOException exception) {  Â Â Â Â // handle I/O problems. } 

Choice C:Â 
try (@BufferedReader reader) { Â Â Â Â reader = new BufferedReader(new InputStreamReader( new URL Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ("http://www.epractizelabs.com/serverdate.html").openStream())); Â Â Â Â String line = reader.readLine(); Â Â Â Â SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY"); Â Â Â Â Date date = format.parse(line); } catch (ParseException | IOException exception) {  Â Â Â Â // handle I/O problems. } 

Question 32
static void aMethod() throws RuntimeException
{
	throw new NullPointerException(); // Exception cannot go here.
}
...
	try
	{
		aMethod();
	} catch (ClassCastException cce)
	{
		System.out.println("cce");
	} finally
	{
		System.out.println("finally");
	}
Not sure exactly what we were talking abut there.  The following code runs fine and produces the output "finally" and then the npe thrown in the method:
	static void bMethod() throws RuntimeException
	{
		throw new NullPointerException(); // Exception cannot go here.
	}

	private static void testException()
	{
		try
		{
			bMethod();
		} catch (ClassCastException cce)
		{
			System.out.println("cce");
		} finally
		{
			System.out.println("finally");
		}
	}

Question:
abstract class A {
	String name = "OCA Java SE 7";
	abstract String getName() throws Throwable;
}
class B extends A {
	String s = "OCP Java SE 7";
	String getName()throws Exception {
		if (true) throw new Exception("Error");return s;
	}
}
public class Test14 {
	public static void main(String[] args) {
		A obj = new B();
		System.out.println(obj.getName());
	}
}

Answer:
This program has nothing to do with the Exception vs. Throwable/checked vs unchecked situation we thought it was.  It will not compile due to the getName() method call.  The reference variable used to invoke the method is of type A.  The getName() method is class A throws a Throwable, which is not handled at the place where it is invoked.  Even though the actual object at runtime is of type B, the compiler looks for a matching method in class A.  It finds the method in the superclass which declares to throw the Throwable and gives and error that Throwable should be caught or declared to be thrown.
If we surround the getName() method call in a try catch block like this, then the class will compile:
		try
		{
			System.out.println(obj.getName());
		} catch (Throwable t)
		{
			System.out.println("throwable");
		}

Question:
interface A {}
class B implements A {}
class C extends B {}
public class Test16 {
	public static void main(String[] args) {
			A a1 = new B();
			A b1 = new C();
			a1 = b1;
			C b2 = (C)a1;
		}	
}

Answer:
The only explaination given: "the object reference at line 9 is valid". 

Question:
try {
	throw new Exception();
} catch (Exception ne) {
	throw ne;
	System.out.println("Inside Exception");
} finally {
	System.out.println("Inside Finally");
}
a. Prints "Exception" and "Finally"
b. Prints "Finally"
c. Prints "Exception"
d. Does not compile.

Answer:
What is the output?  Will it compile or no?  Have to read all the answers to see that the only valid one is the final one.  Maybe the test makers just made a mistake, but that's no excuse for us.  Anyhow, we didn't see why.
The line that prints "Inside Exception" is unreachable.  That's a compile time error.

Question:
The try-catch block should catch the exceptions in the order from specific to generalized.  Hence the order should be FileNotFoundException, IOException and Exception.  FileNotFoundException is the subclass of IOException and IOException is the subclass of Exception.
import java.io.*;
class ExceptionTest {
	public static void main(String[] args) {
		try {
			File f = new File("first file");
			throw new A? e1();
		} catch (B? e2)
		{
			System.out.println("inside 1");
		} catch (C? e3)
		{
			System.out.println("inside 2");
		} catch (D? e4)
		{
			System.out.println("inside 3");
		} finally 
		{
			System.out.println("inside 4");
		}
	}
}
Drag and drop the correct exceptions to make the program print inside 4:
Exception
IOException
FileNotFoundException

Answer:
There is a compiler warning: unreachabe catch clause at the IOException.  Thrown type FileNotFoundException has already been caught.  The answer in the lab said:
A FileNotFoundException
B FileNotFoundException
C IOException
D Exception
But since the code does not compile... The warning is actually a compile error?  If you want to reach the finally block, then you need to throw an exception that will not be caught here.  We can't see the choices anymore, but we can guess that a RuntimeException might do it.
If we throw that, then there are real compiler errors that say: exception IOException and fnfe are never thrown in the body of the corresponding try statement.



**The List Class** ----------------------------------------------

Which are List objects?
- ArrayList
- LinkedList
- Vector
- Stack


**The equals Method** --------------------------------------------

- the equals() method will return false if the objects are not the same class.

Boolean b1 = new Boolean("TRUE");
boolean b2 = true;
if (b1==b2) // true
if (b1.equals(b2)) // true
if (b1.booleanValue()==b2) // true

By contract, if two objects are equivalent according to the equals() method, the  the hashCode() method must evaulate them to be ==.  
if (x3.equals(x4))
x3.hashCode() == x4.hashCode();

Question:
public class Test8
{
	static String s1 = "Java";
	public static void main(String args[]) {
		String s2 = "Java";
		String s3 = new String(s1);
		System.out.println("1 "+(s1==s2));        // true
		System.out.println("2 "+(s1.equals(s2))); // true
		System.out.println("3 "+(s3==s1)); 	   	  // false
		System.out.println("4 "+(s3.equals(s1))); // true
		System.out.println("5 "+(Test9.s4==s1));  // true
	}
}
class Test9
{
	static String s4 = "Java";
}

Answer:
Only 3(line 10?) will print false.  Strings are immutable objects.  That is, a string is read only once the string has been created and initialized, and Java optimizes handling of string literals; only one anonymous string object is shared by all string literals with the same contents.  Hence in the above code, the strings s1, s2 and s4 refer to the same anonymous string object, initialized with the character string "Java".  This, s1 ==s2 and Test9.s4 will both return true and obviously s1.equals(s2) will return true.

Vector<String> employeeList = new Vector<String>();
Vector<Integer> employeeIdList = new Vector<Integer>();
Vector<Object> employeeProfileList = new Vector<Object>();
System.out.println(employeeList.getClass() == employeeIdList.getClass());
System.out.println(employeeList.getClass() == employeeProfileList.getClass());
System.out.println(employeeList.equals(employeeProfileList));
System.out.println(employeeIdList.equals(employeeProfileList));
All instances of a generic class have the same runtime class, regardless of their actual type parameters.  So the getClass() method returns a java.util.Vector for both x and y.  Since no data has been added to both Vector objects, they are also meaningfully equal.  So the equals method returns true here and the output is true, true, true, true.


**The == Operator** ---------------------------------------

Question:  Will this work?
String str = "10";
int a = new Integer(10);
boolean b = str==a;

Answer:
The comparison is not legal, as only the + operator performs the implicit conversion to a String object.
ie: b = str==a+""


Question:
boolean b = false;
boolean c = true;
if (b = c) print("true");

Answer:
The if evaluates to true because the assigment statement also has a value equal to the value being assinged.  Using the == operator provides expected behaviour.
if (b == c) ... false

Question:
Integer a = 123;
float b = 123f;
boolean c = false;
if (c|a==b) print("true");

Answer: The a==b will be evaluated first, so the answer is true.

Question: WIll this compile?
String str = "1";
Integer a = 1;
boolean b=str==a;

Answer: will not compile.  Incomparable types: String and Integer 

Question:
Character obj = 65;
char c = 65;
if c==obj 

Answer: true

		Byte b1 = 1;
		byte b2 = 1;
		System.out.println((b1==b2));

Answer: true


-0.0 == 0.0 is true.


**The instanceof Operator** ---------------------------------

String num = "0";
num = null;
if (num instanceof Object) ... false!
- null compared with a string is not equal.


**Operators** -----------------------------------------------

byte b1 = 1;
byte b2 = 2;
b1 = b1 + b2; // compilation fails
b1 += b2; // compilation successful

**Operator Precedence** -------------------------------------

Consider the following code snippet:
int i = 10;
int n = i++%5;
Question: What are the values of i and n after the code is executed?

Answer: 
i is 11, and n is 0.

Question: What are the final values of i and n if instead of using the postfix increment operator (i++), you use the prefix version (++i))?
    
Answer: 
i is 11, and n is 1.

4 + 5 * 6 / 3 will be treated as 
4 + (5 * (6 / 3)) = ?

When two operators share an operand then operator with the higher precedence gets evaluated first. However, if the operators  have the equal precedence in the same expression then that  expression will be evaluated from left to right except the assignment operators:
a = b = c = 15 is treated as 
a = (b = (c = 15))	

int a = 6;
int b = 5;
int c = 10;
rs = a + (++b)* ((c / a)* b);

x = y = z = 17 
right-to-left associativity
s x = (y = (z = 17))

72 / 2 / 3 
the / operator has left-to-right associativity.
(72 / 2) / 3

int x = 5;
int y = 10;
int z = ++x * y--;
z = 60

	int i = 1;
	int j = 1;
	int k = ++i * j++;  // ijk is 2-2-2

System.out.println("abc " + 1 + 2); = abc 12
System.out.println("abc " + (1 + 2)); = abc 3
System.out.println(1 + 2 + " abc"); = 3 abc!!!  The + operator is left associative, whether it is string concatenation or arithmetic plus.

year % 4 == 0 && year % 100 != 0 || year % 400 == 0

((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)

int a = 1;         
int x = ++a + a++;         
System.out.print(x); // Prints 4 
a becomes 2, even tho the a++ has a higher precedence.
Precedence determines which operands bind to which operators.
Precedence only comes into play if they compete over the same occurrence of an operand. For example: -a++; 
Operator precedence only determines *what* is evaluated, not *when* it is evaluated.
(from left to right) as -(a++) because post-increment has higher precedence than negation. 
Precedence has to do with which operands bind to which operators. It has nothing to do with order of execution. Order of execution (evaluation) is *always* left-to-right in Java. 

int x = 1;  
int y = 1;  
x += y += x += y;  

1 += y += x += y; // evaluate x  
1 += 1 += x += y; // evaluate y  
1 += 1 += 1 += y; // evaluate x, x is still 1 cause no addition takes place yet  
1 += 1 += 1 += 1; // evaluate y  
1 += 1 += 2;      // x is now 2  
1 += 3;           // y is now 3  
4;                // x is now 4  

int y = 1;
y+ = ++y +y++; 
y = y + ++y +y++;
y = y + (++y + y++); ?
y = y++ + (y + y++); ?
y=1 + 2 + 2 

int x = 5;  
int z = ++x * x * x--; // Prints 216  

	i = 10; a = 0;
	int b, c, d; 
	a = (b = i++) + (c = ++i) + (d = i--); 
	//    10			12			12

	int x = 5;  
    int z = ++x * x--;  
The output is 36 because x is incremented first.
x = 5
x++ * --x
This is 25.



**Reserved Words** ----------------------------------------

Question: How does this code compile?
Number Float = 99.455f;

Answer: 
Float is not a reserved word.  'float' is.


**The toArray method** ------------------------------------

Question: Will this compile:
Vector<String> set = new Vector<String>();
String[] arr = set.toArray();

Answer:  
The toArray() method returns Object[], so to compile, the set must be cast to String.  You can fix it like this:
String[] arr = (String [])set.toArray();

Question:  What will the output be:
import java.util.*;
class Test13
{
	public static void main(String[] args) {
		ArrayList<String> a =new ArrayList<String>();
		a.add("one");
		a.add("two");
		a.add("three");
		String[] s = a.toArray();
		for (String str:s)
		{
			System.out.println(str);
		}
	}
}

Answer: 
Remeber, the toArray() method returns an array of Objects, and needs to be cast to a String array like this:
String[] s = a.toArray(new String[0]);
Trying this fails during runtime:
String[] s = (String[])a.toArray();
ClassCastException: Object cannot be cast to String.
But then we tried these and they worked, so maybe the above was a different prob?
String[] s3 = (String[])al.toArray();
String[] s4 = set.toArray(new String[al.size()]);
String[] s = a.toArray(new String[a.size()]);
works also.  If we choose size 4, then a null string is added to the list.


The size of the array cannot be specified in the following examples:
		int i[] = new int[2] {1,2};
		int j[4] = {1,2,3,4};
The size is given implicitly by the initialization code (instance), never in the declaration of an array (reference).


**Extending Comparable** ----------------------------------

class Test3
{
	public String toString() {
		return "Test3";
	}

	public static void main(String[] args) {
		Set<Test3> s = new TreeSet<Test3>();
		s.add(new Test3()); // Test3 cannot be cast to Comparable.
		s.add(new Test3());
		s.add(new Test3());
		for (Test3 out: s)
			System.out.println(out);
	}
	/**
	Either Test3 has to implement Comparable, or you need to provide a comparator when creating the TreeSet.
	 */
}

To fix this:
class Test3 implements Comparable {
 	@Override
    public int compareTo(Test3 test)
    { /* Custom test */ }
Or, we could use a HashSet which isn's ordered.

Also note this is a RUNTIME error, and the code actually compiles fine, although that seems a little strange in the rigid world of Java.
If we used an ArrayList, then there would be no problem, like this:
ArrayList s = new ArrayList();
Then we get a compile time error in the for loop:
error: incompatible types.  required Test3
found Object
		for (Test3 out: s)
				        ^
Not sure how to fix it.  But the second similar looking question does this:
given:
class A{}
class B extends A{}
class C extends B{}
Will this compile?
		ArrayList a = new ArrayList();
		a.add(new A());
		a.add(new B());
		a.add(new C());
		for (Object object:a)
			System.out.println(object);
A generic type used without type parameters is know as a raw type.  In the above example we assign the generic types to the raw type variable, and then insert different types of objects into it.  The raw type is not type-checked, hence there are no compiler errors but warnings are thrown.  The code also runs fine =)~


**IO** ----------------------------------------------------

Writer w = new BufferedWriter(new FileWriter());
- COMPILE ERROR: No such constructor found.
Writer w = new BufferedWriter(new FileWriter("example"));
- error: unreported exception IOException; must be caught or declared to be thrown.
		try
		{
			Writer w = new BufferedWriter(new FileWriter("example"));
		} catch (java.io.IOException ioe)
		{
			System.out.println(ioe.toString());
		}
If the example directory does not exist it will be created.
Writer w = new BufferedWriter(new FileWriter("name.txt"));
- If the file doesnt exist it will be created.


**Regex** -------------------------------------------------

RegEx question:
java Test x7+y8+z9=4P [4789][+-=]
Test class main has this expression:
System.out.println((args[0].split(args[1])).length);
[abc][vz] Set definition, can match a or b or c followed by either v or z.

Question:
String str = "Java*JSP*EJB*J2EE";
System.out.println(Arrays.toString(str.split("*",-2)));

Answer:
Runtime Exception: java.util.regex.PatternSyntaxException: Dangling meta character * near index 0.
PatternSysntaxException occurs if the regular expressions's syntx is invalid.  Note that to use "*" as a delimiter, we have to specify "\\*" as the regular expression.  Given that, we would split the string into:
[Java, JSP, EJB, J2EE]
We could use the regex "[*]" to get the same result.  Also, the -2 is not needed; the same output is got without it.  
Regarding the limit parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array. If the limit n is greater than zero then the pattern will be applied at most n - 1 times, the array's length will be no greater than n, and the array's last entry will contain all input beyond the last matched delimiter. If n is non-positive then the pattern will be applied as many times as possible and the array can have any length. If n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded.
The string "boo:and:foo", for example, yields the following results with these parameters:
Regex	Limit	Result
:		2		{ "boo", "and:foo" }
:		5		{ "boo", "and", "foo" }
:	    -2		{ "boo", "and", "foo" }
o		5		{ "b", "", ":and:f", "", "" }
o	   -2		{ "b", "", ":and:f", "", "" }
o		0		{ "b", "", ":and:f" }
An invocation of this method of the form str.split(regex, n) yields the same result as the expression:
Pattern.compile(regex).split(str, n)



**Initial Capacity** --------------------------------------

String c = new String("1234567890");
StringBuffer sb = new StringBuffer(c);
- The capacity for sb is now 10+16 = 26


**Printf** ------------------------------------------------

      double d_num = 999.3568;
      System.out.printf("% .2f", d_num);
Output: 999.36


**Switch** ------------------------------------------------

- case labels only accept constant (final) expressions.

public class Test11
{
	public static void main(String[] args) 
	{
		Integer  arg = 20;
		switch(arg)
		{
			default:
				System.out.println("default");
			case 10:
				System.out.println("100");
			case 20:
				System.out.println("200");
		}
	}
}
The class compiles and runs fine.  Obviously the position of the dafault case doesn't matter.  The Integer wrapper class in unboxed and 200 is printed out.
And infact, the default condition seems unreachable.


**Constructors** ------------------------------------------

class Test {
	public void Test(String a){print(a);}
	public void Test(int b){print(b);}
	public void Test(){print("None");}
}
Question:  What is printed when you create a new Test();?

Answer: 
Nothing, those are not constructors because of the void return type modifier.

Question:  What will the output be?
class A {A() {System.out.print("Super ");}}
public class Main extends A {
Â Â Â Â public static void main(String [] args) {
Â Â Â Â Â Â Â Â new Main(1L).Main();
Â Â Â Â }
Â Â Â Â public Main(int x) {
Â Â Â Â Â Â Â Â this();
Â Â Â Â Â Â Â Â System.out.print(" " + (x * 2));
Â Â Â Â }
Â Â Â Â public Main(long x) {
Â Â Â Â Â Â Â Â this((int) x);
Â Â Â Â Â Â Â Â System.out.print(" " + x);
Â Â Â Â }
Â Â Â Â public Main() {
Â Â Â Â Â Â Â Â super(); 
Â Â Â Â Â Â Â Â System.out.print("No arg Sub");
Â Â Â Â }
Â Â Â Â void Main() {
Â Â Â Â Â Â Â Â System.out.print(" method "); 
Â Â Â Â }
}

Answer:
Super No arg Sub 2 1 method


- creating a class without a no args constructor causes a COMPILER error when creating the class with a no args constructor!!!


**The 'this' keyword** ------------------------------------


Question:
int subTotal;
static int total;
public void calculate()
{
	int local;
	local = this.total; //1
	local = this.subTotal; //2
	this.total = total; //3
	this.local = 4; // 4
	this = new ExamQuestions(); // 5

Answer:
-  Non-static mehods have an implicit 'this' object reference.  The this reference cannot be changed.  (5)
- The 'this' reference can be used in a non-static context to refer to both instance and static members.
- It cannot be used to refer to local variables. (see 4) "Cannot find symbol" error.


**Pass by Reference** -------------------------------------

Class A {
	int a =200;
	A(int b) {
		this.a=b;
	}
}
Class Test {
	static void a1(int a) {
		a=-1;
	}
	static void a1(A a) {
	a.a=-1;
	}
	public static void main(String as[]) 
	{
		int a=100;
		a1(a);
		A b = new A(400);
		a1(b);
		System.out.print(a+" "+b.a);
	}
}

Answer:
Output: 100 -1

Question:
public class RefObject {
	String class_name = "RefObject";
	RefObject() {
		className = "RefObject_200";
	}
	static void method1(Object ob) {
		ob = null;
	}
	public static void main(String[] args) {
		RefObject refOb = new RefObject();
		method1(refOb);
		System.out.println(RefOb.className);
	}
}

Answer:
When a method which takes an object argument is invoked, the method obtains a copy of the object reference from the calling method.  So altering the object within the method affects the original object passed.  Hence the output "RefObject_200" will be printed.
The method1() call merely sets the copy of the reference to null, but does not change the object, or the original reference to the object held in the refOb variable.



**Enum** --------------------------------------------------

- It's possible to loop an enum with an enhanced for look using the values() method:
enum Direction {
   NORTH,
   EAST,
   SOUTH,
   WEST
}
for (Direction dir : Direction.values()) {
  // do what you want
}


Question:
enum Month {JAN,FEB,MAR,APR,MAY}
public class Test10
{
	public static void main(String[] args) {
		Month mon = Month.valueOf("JAN");
		if(mon==Month.JAN)
			System.out.println("Inside JAN 1");
		if(mon.equals(Month.JAN))
			System.out.println("Inside JAN 2");
	}
}

Answer:
The valueOf() method returns the enum constant whose value corresponds to the string argument passed in.  The enum constant can be compared for == relational operator or the equals() method, since they are instances of the declared enumeration type.  The output will be 
Inside JAN 1
Inside JAN 2


**Threads** -----------------------------------------------

Question:
public class MyThread extends Thread
{
	MyThread(int i)
	{
		this.i = i;
	}
	static int i = 0;
	public void run()
	{
		System.out.println(i);
	}
	public static void main(String[] args) {
		for(int i = 0; i < 10; i++)
		{
			new Thread().start();
		}
	}
}

Answer:
Will this compile and run?  Notice MyThread is not started, but Thread.  To start MyThread, we need to supply an argument:
new MyThread(11).start();
This will print 11 ten times. 


**Random** ------------------------------------------------

line 10:	Integer e;
1ine 11:	System.out.println(e); 
// compile time error at line 11, not in the previous line!

- j2ee-struts is not a valid identifier because it has a SLASH!!!

A static method can only be hidden by another static method.  A static variable may be hidden by an instance variable.

The combination of 'abstract' and 'synchronized' modifiers are not allowed.

According to the JavaBean naming standards, if the boolean property is named 'x', the accessor method is of the form boolean isX() and the mutator method is of the form void setX(boolean newValue)

variable arguments (varargs) allows a method to be called with ZERO or more arguments.

Class members cannot use the this keywords as there is no this to refer to.

False: Member inner classes are the static class.(?)

Finalize will always run before an object is garbage collected.

Questions: When using the writeObject method to store (serialize) the state of an object, how can you protect sensitive data from being acessed in the stored object?

Answer: 
declare the sensitive fields as private transient.

Question: Which of the following keywords is used when a constructor calls an overload constructor in the same class.

Answer: 
this

- super() must be the first statement in a subclass contructor.

quote(String s) returns a literal pattern string for the specified String.  This method produces a String that can be used to create a Pattern that would match the String s as if it were a literal pattern. Meta characters or escape sequences in the input sequence will be given no special meaning.

- Number is the super class for many wrapper classes, but not Boolean and Character

- The split() and matches() methods are present in both String and Pattern class.

      Object obj = 99;
      System.out.println(obj);
This looks odd but it compiles.  However, there would be no output.  Not true, 99 will be printed!
By autoboxing, 99 int primitive value will be automatically converted to Integer object and assigned to the variable obj.

		List list2 = new ArrayList<String>();
		list2.add(new StringBuilder("123"));
This will compile because list2 is a raw type variable,
and no checking is done at compile time.
However, if you try this:
String sbu = list2.get(0);
You will get a compile error: found Object, required String.

System.out.println(new Integer(0).booleanValue());
There is no such method in the Integer class.

Question:  Will this class compile?
class Test6<Ob>
{
	static Ob getOb()
	{
		return null;
	}
}

Answer: 
Compile error: non-static type variable Ob cannot be referenced from a static context.
* Not sure why in this case...

- finalize will always run before an object is garbage collected.

- Member inner classes are the static class

Question:  Will this work as a class variable?
private synchronized int e;

Answer:
This is an invalid class level (nonlocal) variable declaration.
Compile time error: modifier synchronized not allowed here.

Methods shared by the String and the Pattern class:
- split
- matches

public static void main(String [] args) {}
public void main(String ...arg){}
- This class will not compile as the method signatures are the same.

- casting from a child class to a parent class is called implicit casting.

- Object references are passed by value. Additionally Strings are immutable.  Passing  a String to a method creates a new string object that the copy of the reference now points to. The original reference still points to the original string.
It would be like creating a new String object.
void foo( object o )
{
    o = new Object( );  // original reference still points to old value on the heap
}

Question:
boolean a = true;
boolean b = false;
boolean c = true;
if (a && (b = c)) 

Answer:
An assignment statement also has a value equal to the value being 
assigned, hence (b = c) evaluates to true.

Question:
public class Test {
	static int i = j;
	static int j = 10;
}

Answer:
Compile error: illegal forward reference.

Question:
		int y;
		System.out.println("y before init "+y);
		y = 100;

Answer:
Even tyring to print an unitialized variable fails upon compile with the error: variable y might not have been initialized. 

Question:
method()
{
	int x = 10;
	int y;
	if (x < 100) y = 100;
		if (x >= 100) y = x * 10;
			print("Y is "+y);
}

Answer:
Will not compile with the warning that the variable y may not have been initialized.


Question:
method()
{
	int x = 10;
	int y;
	if (x < 100) y = 100;
		if (x >= 100) y = x * 10;
			print("Y is "+y);
}

Answer:
Will not compile with the warning that the variable y may not have been initialized.


- logical operators &&,||, ! and ?: always use boolean operands. 
- bitwise operators and shift operators allow numeric operands.

- primitives and String objects will not be changed in methods.  Other objects can be changed.

Question:
Class ExamQuestions = ExamQuestions.class;

Answer:
This code is fine.  We thought it would trigger a ClassCastException, but it won't.

