

Question:1 
What will the following program snippet print?
   int i=0, j=11;
   do{
      if(i > j) { break; }
      j--;
   }while( ++i < 5);
   System.out.println(i+"  "+j);

Answer: ++i < 5 means, increment the value of i and then compare with 5. Now, Try to work out the values of i and j at every iteration. To start with, i=0 and j=11. At the time of evaluation of the while condition, i and j are as follows:
j = 10 and i=1 (loop will continue because i<5) (Remember that comparison will happen AFTER increment i because it is ++i and not i++.
j = 9 and i=2 (loop will continue because i<5).
j = 8 and i=3 (loop will continue because i<5).
j = 7 and i=4 (loop will continue because i<5).
j = 6 and i=5 (loop will NOT continue because i not <5).
Correct response: it will print 5 6. (It is print i first and then j).
Category: Using Loop COntructs: Very Tough

Question: 2
Note: This question may be considered too advanced for this exam. 
What will the code shown below print when compiled and run with the following command line?  java WarZone self   
interface XMen {
   void shoot(String a);
}

public class WarZone {
   public static void main(String[] args){
       XMen x = null;
       if(args.length() > 0){
          x = new XMen(){
             public void shoot(String s){
                for(int i=0; i<s.length; i++){
                  System.out.println("shot : "+s.charAt(i));
                }
             }
          };
       }
       
       if(x != null){
          x.shoot(args[0]);
       }
   }
}
1. It will not compile because interface XMen cannot be instantiated.
2. It will print shot :   4 times, one at each line.
3. It will print "shot : s", "shot : e", "shot : l", "shot : f" one by one on 4 lines.
4. It will compile but will throw an exception at runtime.
5. None of these options is correct.

Answer:
1. An anonymous inner class that implements XMen interface is being created.
2. This would be correct, if args.length() is changed to args.length and s.length to s.length().
5. Read the question carefully. 'args' is an array and length is an attribute (not a method) of arrays. 's' is a String and there is no attribute length in a String but a method length(). Expect questions that try to confuse by adding misleading statements.
Correct response: 5.  No correct options.
Category: Java Basics  (Marked Question)

Question 3:
Note: This question may be considered too advanced for this exam. Given:
class MySuper{
    public MySuper(int i){ }
}

abstract class MySub extends MySuper{
    public MySub(int i){ super(i); }
    public abstract void m1();
}

class MyTest{
    public static void main(String[] args){
        MySub ms = new MySub(){
            public void m1() { System.out.println("In MySub.m1()"); }
        };
        ms.m1();
    }
}
What will be the output when the above code is compiled and run?
1. It will not compile.
2. It will throw an exception at run time.
3. It will print In MySub.m1()
4. It will compile and run without any exception but will not print anything.
5.

Answer:
1. When you define and instantiate an anonymous inner class for an abstract class as being done here, the anonymous class is actually a subclass of the abstract class (in this case, it is a subclass of MySub). Now, since the anonymous class does not define any constructor, the compiler will add the default no-args constructor to the anonymous class, which will try to call the no-args constructor of its super class MySub. But MySub doesn't have any no-args constructor. Therefore, it will not compile. The anonymous inner class should have been created like this: MySub ms = new MySub( someInteger ){ ... };
Correct response: 1
Category: Working with Inheritance (Marked Question)

Question 4:
Given the following code, which statements are true?

interface Automobile { String describe(); }

class FourWheeler implements Automobile{
   String name;
   public String describe(){ return " 4 Wheeler " + name; }
}

class TwoWheeler extends FourWheeler{
    String name;
    public String describe(){ return " 2 Wheeler " + name; }
}
1. An instance of TwoWheeler is also an instance of FourWheeler.
2. An instance of TwoWheeler is a valid instance of Automobile.
3. The use of inheritance is not justified here because a TwoWheeler is not really a FourWheeler.
4. The code will compile only if name is removed from TwoWheeler.
5. The code will fail to compile.

Answer:
The use of inheritance in this code is not justifiable, since conceptually, a TwoWheeler is-not-a FourWheeler. 
Correct response: 1, 2, and 3.
Category:

Question 5:
What will be the output when the following program is run?

public class TestClass{
    char c;
    public void m1(){
        char[ ] cA = { 'a' , 'b'};
        m2(c, cA);
        System.out.println( ( (int)c)  + ", " + cA[1] );
    }
    public void m2(char c, char[ ] cA){
        c = 'b';
        cA[1] = cA[0] = 'm';
    }
    public static void main(String args[]){
        new TestClass().m1();
    }
}
1. Compile time error.
2.  ,m
3. 0,m
4. b,b
5. b,m

Answer:
1. c is an instance variable of numeric type so it will be given a default value of 0, which prints as empty space.
2. Because of the explicit cast to int in the println() call, c will be printed as 0.
Note that Arrays are Objects (i.e. cA instanceof Object is true) so are effectively passed by reference. So in m1() the change in cA[1] done by m2() is reflected everywhere the array is used. c is a primitive type and is passed by value. In method m2() the passed parameter c is different than instance variable 'c' as local variable hides the instance variable. So instance member 'c' keeps its default (i.e. 0) value.
Correct response: 3.
Category: Working with Methods: Very Easy



Question 7:
What will be the output of the following class...

class Test{
   public static void main(String[] args){
      int j = 1;
      try{
         int i = doIt() / (j = 2);
      } catch (Exception e){
         System.out.println(" j = " + j);
      }
   }
   public static int doIt() throws Exception {  throw new Exception("FORGET IT");  }
}
1. It will print j = 1;
2. It will print j = 2;
3. The value of j cannot be determined.
4. It will not compile.
5. None of the above.

Answer:
If evaluation of the left-hand operand of a binary operator completes abruptly, no part of the right-hand operand appears to have been evaluated.
So, as doIt() throws exception, j = 2 never gets executed.
Correct response: 1
Category: Handling Exceptions: Easy


Question 11:
Consider the following class...  class MyString extends String{    MyString(){ super(); } }   The above code will not compile.
True or False?

Answer:
This will not compile because String is a final class and final classes cannot be extended. There are questions on this aspect in the exam and so you should remember that StringBuffer and StringBuilder are also final. All Primitive wrappers are also final (i.e. Boolean, Integer, Byte etc). java.lang.System is also final.
Correct response: true (it will not compile)
Category: Working with Java Data Types.


Question 12:
What will the following code print?
void crazyLoop(){
   int c = 0;
   JACK: while (c < 8){
       JILL: System.out.println(c);
       if (c > 3) break JILL; else c++;
   }
}

1. It will not compile.
2. It will throw an exception at runtime.
3. It will print numbers from 0 to 8
4. It will print numbers from 0 to 3
5. It will print numbers from 0 to 4

Answer:
Because break JILL; would be valid only when it is within the block of code under the scope of the label JILL. In this case, the scope of JILL extends only up till System.out.println(c); and break JILL; is out of the scope of the label. 
Correct response: 1
Category: Using Loop Contructs

Question 14:
Consider the following class:  
public class ArgsPrinter{    
	public static void main(String args){       
		for(int i=0; i<3; i++){          
			System.out.print(args+" ");       
		}    
	}
}  
What will be printed when the above class is run using the following command line: java ArgsPrinter 1 2 3 4

Answer:
To run a class from the command line, you need a main(String[] ) method that takes an array of Strings array not just a String. Therefore, an exception will be thrown at runtime saying no main(String[] ) method found.
Correct response: Runtime exception
Category: Java Basics

Question 18:
Given the following classes, what will be the output of compiling and running the class Truck?
class Automobile{
   public void drive() {  System.out.println("Automobile: drive");   }
}

public class Truck extends Automobile{
   public void drive() {  System.out.println("Truck: drive");   }
   public static void main (String args [ ]){
      Automobile  a = new Automobile();
      Truck t  = new Truck();
      a.drive(); //1
      t.drive(); //2
      a = t;     //3
      a.drive(); //4
   }
}
1. Compiler error at line 3.
2. Runtime error at line 3.
3. It will print:  Automobile: drive Truck: drive Automobile: drive in that order.
4. It will print: Automobile: drive Truck: drive Truck: drive in that order.
5. It will print: Automobile: drive Automobile: drive Automobile: drive in that order.

Answer:
Since Truck is a subclass of Automobile, a = t will be valid at compile time as well runtime. But a cast is needed to make for t = (Truck) a; This will be ok at compile time but if at run time 'a' does not refer to an object of class Truck then a ClassCastException will be thrown. Now, method to be executed is decided at run time and it depends on the actual class of object referred to by the variable. 
Here, at line 4, variable a refers to an object of class Truck. So Truck's drive() will be called which prints Truck: drive. This is polymorphism in action!
Correct response: It will print: 4
Automobile: drive 
Truck: drive 
Truck: drive 
in that order.
Category: Working with Inheritance.

Question 20:
A try statement must always have a ............. associated with it.
1 . catch
2. throws
3. finally
4. catch, finally or both
5. throw

Answer:
A try without resources must have either a catch or a finally. It may have both as well. Thus, the following constructs are valid:  
1. try{ } 
catch(Exception e){  }          // no finally  
2. try{ } finally{  }          // no catch  
3. try{ } catch(Exception e){  } finally{  }  
4. A catch can catch multiple exceptions: try{ } catch(Exception1|Exception2|Exception3 e){  }   
Note: try with resources (which is not on this exam) may omit catch as well as finally blocks.
Correct response: 4
Category:

Question 21:
Note: This question may be considered too advanced for this exam.  Which statements can be inserted at line 1 in the following code to make the program write x on the standard output when run?

public class AccessTest{
   String a = "x";
   static char b = 'x';
   String  c = "x";
   class Inner{
      String  a = "y";
      String  get(){
         String c = "temp";
         // Line 1
         return c;
      }
   }

   AccessTest() { 
     System.out.println(  new Inner().get()  ); 
   }

   public static void main(String args[]) {  new AccessTest();  }
}

1. c = c;
2. c = this.a;
3. c = ""+AccessTest.b;
4. c = AccessTest.this.a;
5. c = ""+b;

Answer:
1. It will reassign 'temp' to c!
2. It will assign "y" to c.
3. Because b is static.
Correct response: 3, 4 and 5.
Category: Working with Java Data Types

Question 23:
Note: This question may be considered too advanced for this exam. Given: String mStr = "123"; long m = // 1 Which of the following options when put at //1 will assign 123 to m?
1. new Long(mStr);
2. Long.parseLong(mStr);
3. Long.longValue(mStr);
4. (new Long()).parseLong(mStr);
5. Long.valueOf(mStr).longValue();

Answer:
1. Auto unboxing will occur.
3. longValue is a non-static method in Long class.
4. Long (or any wrapper class) does not have a no-args constructor, so new Long() is invalid.
5. Long.valueOf(mStr) returns a Long object containing 123. longValue() on the Long object returns 123.
Correct response: 1, 2 & 5.
Category: Working with Java Data Types

Question 24:
Consider the following method -
public float parseFloat( String s ){
   float f = 0.0f;
   try{
      f = Float.valueOf( s ).floatValue();
      return f ;
   }
   catch(NumberFormatException nfe){
      f = Float.NaN ;
      return f;
   }
   finally{
      f = 10.0f;
      return f;
   }
}
What will it return if the method is called with the input "0.0" ?
1. It will not compile.
2. It will return 10.0
3. It will return Float.Nan
4. It will return 0.0
5. None of the above.

Answer:
finally block will always execute (except when there is a System.exit() in try or catch). And inside the finally block, it is setting f to 10.0. So no matter what the input is, this method will always return 10.0.
Correct response: 2.
Category: Handling Exceptions

Question 25:
What, if anything, is wrong with the following code?
// Filename: TestClass.java
class TestClass implements T1, T2{
   public void m1(){
   		TestClass tc = new TestClass();  // 1
   		System.out.println(( ( T1) tc).VALUE); // 2
   		System.out.println(VALUE);  // 3
   }
}
interface T1{
   int VALUE = 1;
   void m1();
}
interface T2{
   int VALUE = 2;
   void m1();
}

Answer:
Having ambiguous fields or methods does not cause any problems by itself but referring to such fields/methods in an ambiguous way will cause a compile time error. So you cannot call : System.out.println(VALUE); because it will be ambiguous (there are two VALUE definitions). But the following lines are valid :  TestClass tc = new TestClass(); System.out.println(( ( T1) tc).VALUE);  However, explicit cast is not required for calling the method m1() : ( ( T2) tc).m1(); tc.m1() is also fine because even though m1() is declared in both the interfaces, the definition to both resolves unambiguously to only one m1(), which is defined in TestClass.
Correct response: Complie time error.
Category: Working with Inheritance.

Question 26: 
Note: This question may be considered too advanced for this exam. What will the following code print when run?

public class TestClass{	
    public static Integer wiggler(Integer x){
       Integer y = x + 10;
       x++;
       System.out.println(x);
       return y;
    }

    public static void main(String[] args){
       Integer dataWrapper = new Integer(5);
       Integer value = wiggler(dataWrapper);
       System.out.println(dataWrapper+value);
    }
}

Answer:
1. Wrapper objects are always immutable. Therefore, when dataWrapper is passed into wiggler() method, it is never changed even when x++; is executed. However, x, which was pointing to the same object as dataWrapper, is assigned a new Integer object (different from dataWrapper) containing 6.  
2. If both the operands of the + operator are numeric, it adds the two operands. Here, the two operands are Integer 5 and Integer 15, so it unboxes them, adds them, and prints 20.

Correct response: 6 and 20.
Category: 

Question 29: 
Which is the first line that will cause compilation to fail in the following program?

// Filename: A.java
class A{
   public static void main(String args[]){
      A a = new A();
      B b = new B();
      a = b;  // 1
      b = a;  // 2
      a = (B) b; // 3
      b = (B) a; // 4
   }
}
class B extends A { }

Answer:
Because 'a' is declared of class A and 'b' is of B which is a subclass of A. So an explicit cast is needed.
Casting a base class to a subclass as in : b = (B) a; is also called as narrowing (as you are trying to narrow the base class object to a more specific class object) and needs explicit cast. 
Casting a sub class to a base class as in: A a = b; is also called as widening and does not need any casting.  
For example, consider two classes: Automobile and Car, where Car extends Automobile 
Now, Automobile a = new Car(); is valid because a car is definitely an Automobile. So it does not need an explicit cast.  
But, Car c = a; is not valid because 'a' is an Automobile and it may be a Car, a Truck, or a MotorCycle, so the programmer has to explicitly let the compiler know that at runtime 'a' will point to an object of class Car. Therefore, the programmer must use an explicit cast: Car c = (Car) a;
Correct response: line 2
Category:  Working with Inheritance: Very Easy

Question 30: 
Identify the valid for loop constructs assuming the following declarations:
Object o = null;
Collection c = //valid collection object.
int[][] ia = //valid array
1. for(o : c){ }
2. for(final Object o2 :c){ }
3. for(int i : ia) { }
4. for(Iterator it : c.iterator()){ }
5. for(int i : ia[0]){ }

Answer:
1. Cannot use an existing/predefined variable in the variable declaration part.
2. final is the only modifier (excluding annotations) that is allowed here.
3. Each element of ia is itself an array. Thus, they cannot be assigned to an int.
4. c.iterator() does not return any Collection. Note that the following would have been valid: Collection<Iterator> c = //some collection that contains Iterator objects for(Iterator it : c){ }
5. Since ia[0] is an array of ints, this is valid. (It may throw a NullPointerException or ArrayIndexOutOfBoundsException at runtime if ia is not appropriately initialized.)
Correct response: 2 and 5.
Category: 

Question 31: 
Note: This question may be considered too advanced for this exam.  Given the declaration  
interface Worker { void perform_work(); }  
which of the following methods/classes are valid?
1. Worker getWorker(int i){
2. Worker getWorker(final int i){
3. Worker getWorker(int i){
4. 
5. 

Answer:
1. Since method parameter i is not final, it cannot be accessed from perform_work().
2. Since method paramter 'i' is final, it can be accessed from perform_work();
3. x is not accessible from within perform_work() either. In fact, i and x are similar for all practical purposes in terms of accessibility.
4. 
Worker getWorker(final int i){    
	class MyWorker implements Worker {          
		public void perform_work() { System.out.println(i); }    };    
	return new MyWorker(); }
Do not get confused with option 2. You are not instantiating an interface, you are instantiating an anonymous class that implements the interface Worker.   FYI, if you have a nested static class MyWorker in TestClass as follows, 
public class TestClass{    
	public static class MyWorker implements Worker{        
		public MyWorker(int i){ }        
		public void perform_work(){ }    
	} 
}  
MyWorker can be instantiated in any other class by doing: new TestClass.MyWorker( someInt );  
There is no instance of TestClass associated with the MyWorker class in this case. Inside TestClass you can instantiate MyWorker directly  (new MyWorker(someInt)) in static or non static context.  
Remember: A nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class. An inner class is a nested class that is not explicitly or implicitly declared static. A class defined inside an interface is implicitly static.
Correct response: 2 and 4.
Category: Working with Inheritance: Tough
It looks like the explaination for number 2 is wrong.  What x are they talking about?

Question 32: (modified) 
Consider the following code:

public class Varargs{
   public void test(){
        test1(10, 20);  //1
   }

   public void test1(int i, int... j){ System.out.println("1"); }
   public void test1(int i, int j){ System.out.println("3"); }

   public static void main(String[] args){
     new Varargs().test();
   } 
}
What will the program print?

Answer:
Correct response: Will not compile
It would compile if this method was added:
public void test1(int... i ){ System.out.println("2"); }
Category: 

Question 34: 
Consider the following class hierarchy

class A{
   public void m1() {   }
}
class B extends A{
   public void m1() {   }
}
class C extends B{
   public void m1(){
      /*  //1
      ... lot of code.
      */
   }
}
1. You cannot access class A's m1() from class C for the same object ( i.e. this).
2. You can access class B's m1() using super.m1() from class C.
3. You can access class A's m1() using ( (A) this ).m1() from class C.
4. You can access class A's m1() using super.super.m1() from class C.

Answer:
3. Note that selection of method to be executed depends upon the actual object class. So no matter what you do, in class C you can only access C's m1() even by casting this to B or A. So, this option will not work.
There is no construct like super.super. So, there is no way you can access m1() of A from C.
Correct response: 1 and 2.
Category: Working with Inheritance: Real Brainer.

Question 44: 
What will be the result of attempting to compile and run the following program?

public class TestClass{
   public static void main(String args[]){
      int x  = 0;
      labelA:   for (int i=10; i<0; i--){
         int j = 0;
         labelB:
         while (j < 10){
            if (j > i) break labelB;
            if (i == j){
               x++;
               continue labelA;
            }
            j++;
         }
         x--;
      }
      System.out.println(x);
   }
}
1. Compile error
2. Infinate loop
3. The program will write 10 to the standard output.
4. The program will write 0 to the standard output.
5. None of these

Answer:
This is just a simple code that is meant to confuse you. Notice the for statement: for(int i=10; i<0; i--). i is being initialized to 10 and the test is i<0, which is false. Therefore, the control will never get inside the for loop, none of the weird code will be executed, and x will remain 0, which is what is printed.
Correct response: 4.
Category: 

Question 45: 
What will the following program print when run?
public class TestClass{
  public static void main(String[] args){
     try{
        System.exit(0);
     }
     finally{
         System.out.println("finally is always executed!");
     }
  }
}
1. It will print  "finally is always executed!"
2. It will not compile as there is no catch block.
3. It will not print anything.
4. An exception will be thrown
5. None of the above.

Answer:
finally is always executed (even if you throw an exception in try or catch) but this is the exception to the rule.
When you call System.exit(...); The JVM exits so there is no way to execute the finally block.
Correct response: It will not print anything.
Category: Handling Exceptions: Easy

Question 46: 
This is a Drag and Drop type question. Please click on 'Show DnD Screen' to see the question.
Identify the exceptions.
1. String s = null;
System.out.println(s.length));
2. int[]ia = new int[]{1,2,3};
System.out.println(ia[3]);
3. Class.forName("java.lang.String");
4. public class X {
	static {
	throw new NullPointerException();
	}
}


Answer:
1. npe
2. aioobe
3. will not compile
4. eiie
Please read ExceptionClassSummary document in the "Study References" section.
Note that the question is not asking what exception you need to put in the catch(...) part or throws clause. It is just asking what exceptions will be thrown by the code fragments when they are executed.
Correct response: 
Category: Handling Exceptions: Tough


Question 49: 
Given:     
byte b = 1;   
char c = 1;   
short s = 1;   
int i = 1;  
which of the following expressions are valid?
1. s = b * b ;
2. i = b << b ;
3. s <<= b ;
4. c = c + b ;
5. s += i ;

Answer:
1. b * b returns an int.
3. All compound assignment operators internally do an explicit cast.
4. c + b returns an int
5. All compound assignment operators internally do an explicit cast.
Remember these rules for primitive types: 1. Anything bigger than an int can NEVER be assigned to an int or anything smaller than int ( byte, char, or short) without explicit cast. 2. CONSTANT values up to int can be assigned (without cast) to variables of lesser size ( for example, short to byte) if the value is representable by the variable.( that is, if it fits into the size of the variable). 3. operands of mathematical operators are ALWAYS promoted to AT LEAST int. (i.e. for byte * byte both bytes will be first promoted to int.) and the return value will be AT LEAST int. 4. Compound assignment operators ( +=, *= etc)  have strange ways so read this carefully:  
A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T)((E1) op (E2)), where T is the type of E1, except that E1 is evaluated only once. Note that the implied cast to type T may be either an identity conversion or a narrowing primitive conversion. For example, the following code is correct:  
short x = 3; 
x += 4.6;  
and results in x having the value 7 because it is equivalent to:  
short x = 3; 
x = (short)(x + 4.6);
Correct response: 2,3,5. 
Category: 

Question: 52 
Consider the directory structure shown in Image 1 that displays available folders and classes and the code given below:  
class StockQuote{   S
	tock stock;   
	public StockQuote(Stock s)  {   }   
	public void store() throws IOException{      
		Util.store(stock);   
	}   
	public double computePrice(){     
		return Helper.getPricer(stock).price();   
	} 
}  
Assuming that the code uses valid method calls, what statements MUST be added to the above class?
com.Helper.class -> enthu.Util.class ->  Stock.class
1. package com.enthu.rad.*;
2. import com.enthu.*;
3. package com.enthu.rad;
4. import com.*;
5. import java.io.*;
6. It is not required to import java.io.* or import java.io.IOException because java.io package is imported automatically.

Answer:
1. Bad syntax. A package statement can never have a *. It should specify the exact package name.
3. Since there is no import statement available for com.enthu.rad package, you must put the given class in com.enthu.rad package so that it will be accessible. Classes of the same package are always available to each other.
6. Since the code is using IOException, the java.io package (or just java.io.IOException class) must be imported. Only java.lang package is imported automatically.
Correct response: 2,3,4,5.
Category: 

Question: 53-1
Identify the exceptio that should be thrown below at ***.
switch(suit) {
	case CLUBS:	
	...
	break;
	case DIAMONDS
	...
	break;
	case HEARTS
	...
	break;
	case SPADES
	...
	break;
	default: throw new ***
}

Answer: 
Correct response: AssertionError();
Category: Handling Exceptions: Very Tough

Question: 53-2 
Identify the exceptio that should be thrown below at ***.
public void applyCode(String code)
{
	if (code.startsWith("XA")) apply (code.substring(2));
	else throw new ***
}

Answer:
Correct response: 
IllegalArgumentException();
Category: Handling Exceptions: Very Tough

Question: 54
What will be the result of attempting to compile and run the following program?

public class TestClass{
   public static void main(String args[ ] ){
      A o1 = new C( );
      B o2 = (B) o1;
      System.out.println(o1.m1( ) );
      System.out.println(o2.i );
   }
}
class A { int i = 10;  int m1( ) { return i; } }
class B extends A { int i = 20;  int m1() { return i; } }
class C extends B { int i = 30;  int m1() { return i; } }

Answer:
Remember : variables are SHADOWED and methods are OVERRIDDEN. Which variable will be used depends on the class that the variable is declared of. Which method will be used depends on the actual class of the object that is referenced by the variable. So, in line o1.m1(), the actual class of the object is C, so C's m1() will be used. So it returns 30. In line o2.i, o2 is declared to be of class B, so B's i is used. So it returns 20.
Correct response: It will print 30, 20
Category: Working with Inheritance

Question: 55
Identify valid for constructs...
Assume that Math.random() returns a double between 0.0 and 1.0 (not including 1.0).
1.  for(;Math.random()<0.5;){     
	    System.out.println("true"); 
	}
2.  for(;;Math.random()<0.5){     
		System.out.println("true"); 
	}
3.  for(;;Math.random()){     
		System.out.println("true"); 
	}
4.  for(;;){     
		Math.random()<.05? break : continue; 
	}
5.  for(;;){     
		if(Math.random()<.05) break; 
	}

Answer:
The three parts of a for loop are independent of each other. However, there are certain rules for each part. Please go through section 14.14.1 of JLS to understand it fully.
1. The second expression in a for loop m
2. Here, the first part (i.e. the init part) and the second part (i.e. the expression/condition part) part of the for loop are empty. Both are valid. (When the expression/condition part is emtpy, it is interpreted as true.) 
The third part (i.e. the update part) of the for loop does not allow every kind of statement. It allows only the following statements here:  Assignment, PreIncrementExpression, PreDecrementExpression, PostIncrementExpression, PostDecrementExpression, MethodInvocation, and ClassInstanceCreationExpression. Thus, Math.random()<0.5 is not valid here, and so this will not compile.
3. This is a valid never ending loop that will keep printing true.
4. This is an invalid use of ? : operator. Both sides of : should return the same type (excluding void). Here, break and continue do not return anything. However, the following would have been valid:
for(;Math.random()<.05? true : false;){  }
Correct response: 1, 3 and 5.
Category: Using Loop Constructs

Question: 58
What will the following class print when run?
public class Sample{
   public static void main(String[] args)  {
     String s1 = new String("java");
     StringBuilder s2 = new StringBuilder("java");
     replaceString(s1);
     replaceStringBuilder(s2);
     System.out.println(s1 + s2);
  }
  static void replaceString(String s) {
     s = s.replace('j', 'l');
  }
  static void replaceStringBuilder(StringBuilder s) {
     s.append("c");
  }
}

Answer:
String is immutable while StringBuilder is not. So no matter what you do in replaceString() method, the original String that was passed to it will not change. On the other hand, StringBuilder methods, such as replace or append, change the StringBuilder itself. So, 'c' is appended to java in replaceStringBuilder() method. 
Correct response: 1, javajavac
Category: Working with Java Data Types

Question: 59
What is the correct declaration for an abstract method 'add' accessible to any class, takes no arguments and returns nothing?
(Use only one space between words)
1. public void add();
2. abstract add();
3. abstract null add();
4. abstract public void add(){ }
5. abstract public void add() throws Exception;

Answer:
1. An abstract method must have the abstract keyword and must not have a method body i.e. { }.
2. A method that is not supposed to return anything must specify void as its return type.
3. A method that is not supposed to return anything must specify void as its return type. null is not a  type, though it is a valid return value for any type.
4. It is invalid because has a method body i.e. { }.
Correct response: 5.
Category: Working with Methods.

Question: 60
Which of the given statements are correct for a method that overrides the following method:  public Set getSet(int a) {...}
1. Its return type must be declared as Set.
2. It may return HashSet.
3. It can declare any Exception in throws clause
4. It can declare any RuntimeException in throws clause.
5. It can be abstract.

Answer:
To override a method in the subclass, the overriding method (i.e. the one in the subclass) MUST HAVE: .same name .same return type in case of primitives (a subclass is allowed for classes, this is also known as covariant return types). .same type and order of parameters .It may throw only those exceptions that are declared in the throws clause of the superclass's method or exceptions that are subclasses of the declared exceptions. It may also choose NOT to throw any exception. The names of the parameter types do not matter. For example, void methodX(int i) is same as void methodX(int k)
1. Return type may also be a subclass/subinterface. So it can also return SortedSet, TreeSet, HashSet, or any other class that implements or subclasses a Set.
3. Since the original (overridden) method does not have any throws clause, the overriding method cannot declare any checked exceptions.
4. A method can throw any RuntimeException (such as a NullPointerException) even without declaring it in its throws clause.
5. Yes, you can make it abstract!! You would have to make the class as abstract as well though.
Correct response: 2, 4 and 5.
Category: Working with Inheritance (confidence B and incorrect)

Question: 61
Given the deinitions of I and Klass, complete the definition of SubClass so that it extends from Klass and implements I.  Use the minimum number of elements.
interface I
Put the keywords in the correct order.
{
	void m1();
}
abstract class Klass
{
	vid m1() {};
}
class SubClass _1_ _2_ _3_ _4_
{
	public void m1() P{}
}
1. implments
2. extends
3. Klass
4. I

Answer:
Even though class Klass implements m1(), it does not declare that it implements I. Therefore, for a subclass to 'implement' I, it must have 'implements I' in its declaration. Further, m1() in Klass is not public. So even though Subclass inherits m1() from Klass, it will not be a valid implementation of I because interface methods must be public. Therefore, SubClass must override m1() and make it public.
Correct response: 2, 3, 1, 4.
class SubClass extends Klass implements I
The following order:
class SubClass implements I extends Klass
will cause the following error:
SubClass.java:9: error: '{' expected
class SubClass implements I exteds Klass
						   ^
Category: Working with Inheritance: Easy

Question: 62 modified
The following is a valid member variable declaration:  private static native final transient int i = 20;
True or false?

Answer:
Although it does not make sense to make static variable transient as static variables are not serialized anyway, it is valid to do so. You can apply all the modifiers to member variables except abstract, native and synchronized. For methods, you cannot apply transient and volatile.
Remove the native modifier and the answer would be true.
Correct response: false
Category: Java Basics: Tough

Question: 64
Which of the following statements are true?
1. The condition expression in an if statement can contain method calls.
2. If a and b are of type boolean, the expression (a = b) can be used as the condition expression of an if statement.
3. An if statement can have either an 'if' clause or an 'else' clause.
4. The statement : if (false) ; else ; is illegal.
5. Only expressions which evaluate to a boolean value can be used as the condition in an if statement.

Answer:
The expression (a = b) does not compare the variables a and b, but rather assigns the value of b to the variable a. The result of the expression is the value being assigned. Since a and b are boolean variables, the value returned by the expression is also boolean. This allows the expressions to be used as the condition for an if-statement. if-clause and the else-clause can have empty statements. Empty statement ( i.e. just ; ) is a valid statement. But this is illegal : 
if (true) else; 
because the if part doesn't contain any valid statement. ( A statement cannot start with an else!) So, the following is valid. 
if(true) if(false); 
because if(false); is a valid statement.
1. Yes, as long as the method returns a boolean value.
3. An if-statement must always have an 'if' clause. 'else' is optional.
4. if-clause and the else-clause can have empty statements. Empty statement ( i.e. just  a semi-colon ) is a valid statement.
5. Unlike C/C++ where you can use integers as conditions, in java, only booleans are allowed.
Correct response: 1,2 and 5.
if (false) ; else ; // a valid statement!
Category: Using Operators and decision Constructs: Very Easy

Question: 66 
Given:
StringBuilder b1 = new StringBuilder("snorkler");
StringBuilder b2 = new StringBuilder("yoodler");
Write the contents of b1 and b2 after the statements shown on the left are executed independent of each other.
1. b1.append(b2.substring(2,5).toUpperCase());
2. b2.insert(3, b1.append("a"));
3. b1.replace(3,4,b2.substring(4)).append(b2.append(false));

Answer:
You need to understand how append, insert, delete, and substring methods of StringBuilder/StringBuffer work. Please go through JavaDoc API for these methods. This is very important for the exam. Observe that substring() does not modify the object it is invoked on but append, insert and delete do.  
In the exam, you will find questions that use such quirky syntax, where multiple calls are chained together. For example: sb.append("a").append("asdf").insert(2, "asdf"). Make yourself familiar with this technique. If in doubt, just break it down into multiple calls. For example, the aforementioned statement can be thought of as:  
sb.append("a"); 
sb.append("asdf"); 
sb.insert(2, "asdf")  
Note that the method substring() in StringBuilder/StringBuffer returns a String (and not a reference to itself, unlike append, insert, and delete). So another StringBuilder method cannot be chained to it. For example, the following is not valid: sb.append("a").substring(0, 4).insert(2, "asdf");  The following is valid though:  String str = sb.append("a").insert(2, "asdf").substring(0, 4);
1. snorklerODL yoodler
2. snorklera yoosnorkleradler
3. snolerkleryoodlerfalse yoodlerfalse
Correct response: 
Category: 

Question: 70
Consider the following code snippet:      
for(int i=INT1; i<INT2; i++){         
	System.out.println(i);     
}  
INT1 and INT2 can be any two integers.  Which of the following will produce the same result?
1. for(int i=INT1; i<INT2; System.out.println(++i));
2. for(int i=INT1; i++<INT2; System.out.println(i));
3. int i=INT1; while(i++<INT2) { System.out.println(i); }
4. int i=INT1; do { System.out.println(i); }while(i++<INT2);
5. None of these.

Answer:
In such a question it is best to take a sample data such as INT1=1 and INT2=3 and execute the loops mentally. Eliminate the wrong options. In this case, the original loop will print:
=====ORIGINAL ====
1
2
Outputs of all the options are given above (Ignoring the line breaks).
Thus, none of them is same as the original.
1,2 and 3 print 2 and 3
4 prints 1 2 and 3
Correct response: 5, none of these 
Category: 

Question: 74
Note: Option 4 of this question may be considered too advanced for this exam.  Which lines of code will not be acceptable to the compiler?  
import java.*; //1 
public abstract class InternalLogic //2 
{    
	float density = 20.0; //3    
	public class Doer //4    
	{       
		void do() //5       
		{          //lot of valid code.       }    
	} 
}

Answer:
1. Although it doesn't import anything but import java.*; is valid.
2. A class having no abstract method can still be abstract. But not vice-versa.
3. 20.0 is a double and needs a cast to be assigned to a float. 
4. It is a valid inner class.
5. do is a keyword so do() is not a valid method name.
Correct response: 3 and 5
Category: Java Basics: Very Tough

Question: 79 modified
What will be the output when the following program is compiled and run?
public class TestClass{     
	public static double getSwitch(String str){         
		return Double.parseDouble(str.substring(1, str.length()-1) );     
	}     
	public static void main(String args []){         
		switch(getSwitch(args[0])){             
			case 0.0 : System.out.println("Hello");  
			case 1.0 : System.out.println("World"); break; default : System.out.println("Good Bye");  
		}     
	} 
}

Answer:
Observe that the method getSwitch() has been declared to return a double. Its return value is being used in the switch() statement. Therefore, the program will not even compile because double/float/long/boolean cannot be used in switch(...) statement.
Correct response:  Compile time error
Category: Using Operators and Decision Constructs

Question: 82
Which statements, when inserted in the code below, will cause an exception at run time?
class B {}
class B1 extends B {}
class B2 extends B {}
public class ExtendsTest{
  public static void main(String args[]){
     B b = new B();
     B1 b1 = new B1();
     B2 b2 = new B2();
     // insert statement here
  }
}

1. b = b1;
2. b2 = b;
3. b1 = (B1) b;
4. b2 = (B2) b1;
5. b1 = (B) b1;

Answer:
1. There won't be a problem anytime because B1 is a B
2. It fails at Compile time as an object referenced by b may not be a B2, so an explicit cast will be needed.
3. It will pass at compile time but fail at run time as the actual object referenced by b is not a B1.
4. It will not compile because b1 can never point to an object of class B2.
5. This won't compile. Another cast is needed. i.e. b1 = (B1) (B) b1;
Correct response: 3
Category: Working with Inheritance

Question: 83
Consider the following two java files:  
//in file SM.java 
package x.y; 
public class SM {     
	public static void foo(){ }; 
}   
//in file TestClass.java 
//insert import statement here //1 
public class TestClass{    
	public static void main(String[] args){       
		foo();    
	} 
}   
What should be inserted at //1 so that TestClass will compile and run?

1. import static x.y.*;
2. import static x.y.SM;
3. import static x.y.SM.foo;
4. import static x.y.SM.foo();
5. import static x.y.SM.*;

Answer:
1. x.y.* means all the classes in package x.y. Classes cannot be imported using "import static". You must do import x.y.* for importing class.
Further, importing a class will not give you a direct access to the members of the class. You will need to do SM.foo(), if you import SM.
2. x.y.SM means you are trying to import class x.y.SM. A class cannot be imported statically.
3. This is valid because this statement is importing the static member foo of class x.y.SM.
4. Even though foo is a method, you cannot put () in the import statement.
5. This is valid because this statement is importing all the static members of class x.y.SM.
Correct response: 
Category: 

Question: 85 modified
class A{
  int i = 10;
  public static void m1(){  }
  public void m2() { }
}
class B extends A{
  int i = 20;
  public static void m1() {  }
  public void m2() { }
}
A a  = new B();
System.out.println(a.i)  // 1
a.m1();  // 2
a.m2();  // 3
What will be the output of 1 2 and 3?

Answer:
static methods are never overridden. They are HIDDEN or SHADOWED just like static or non-static fields. For example,
class A{
    public static void sM1() {  System.out.println("In base static"); }
}
class B extends A{
Line 1 :   // public static void sM1() {  System.out.println("In sub static"); }
Line 2 :   // public  void sM1() {  System.out.println("In sub non-static"); }
}
UNLIKE m2, m1() of B does not override m1() of A, it just shadows it.
Correct response: 
1. will print 10 instead of 20
2. will call A's m1
3. will call B's m2 as m2() is not static and so overrides A's m2()
Category: Working with Inheritance 

Question: 86
What will the following program print?

class Test{
    public static void main(String args[]){
        int c = 0;
        boolean flag = true;
        for(int i = 0; i < 3; i++){
            while(flag){
                c++;
                if(i>c || c>5) flag = false;
            }
        }
        System.out.println(c);
    }
}

Answer:
In the first iteration of for loop, the while loop keeps running till c becomes 6. Now, for all next for loop iteration, the while loop never runs as the flag is false. So final value of c is 6.
Correct response: 6
Category: Using Loop Constructs: Easy

Question: 87
Consider the following classes in one file named A.java...  abstract class A{    
	protected int m1(){ 
		return 0; 
	} 
} 
class B extends A{    
	int m1(){ 
		return 1; 
	} 
}  
Which of the following statements are correct...

1. The code will not compile as you cannot have more than 1 class in 1 file.
2. The code will not compile because class B does not override the method m1() correctly.
3. The code will not compile as A is an abstract class.
4. The code will not compile as A does not have any abstract method.
5. The code will compile fine.

Answer:
The concept here is that an overriding method cannot make the overridden method more private.
The access hierarchy in increasing levels of accessibility is:
private->'no modifier'->protected->public ( public is accessible to all and private is accessible to none except itself.)
Here, class B has no modifier for m1() so it is trying to reduce the accessibility of protected to default.
'protected' means the method will be accessible to all the classes in the same package and all the subclasses (even if the subclass is in a different package).
No modifier (which is the default level) means the method will be accessible only to all the classes in the same package. (i.e. not even to the subclass if the subclass is in a different package.)
1. ou can. But only one class can be public.
2. The overriding method cannot decrease the accessibility.
4. You need not have any 'abstract' method to make a class abstract. Putting 'abstract' keyword is enough.
Correct response: 2
Category: Working with Methods: Very Tough (Confidence B and incorrect)

Question: 88
What will be the result of attempting to compile and run the following class?
public class TestClass{
    public static void main(String args[ ] ){
       int i = 1;
       int[] iArr = {1};
       incr(i) ;
       incr(iArr) ;
       System.out.println( "i = " + i + "  iArr[0] = " + iArr [ 0 ] ) ;
    }
    public static void incr(int   n ) { n++ ; }
    public static void incr(int[ ] n ) { n [ 0 ]++ ; }
}

Answer:
Arrays are proper objects (i.e. iArr instanceof Object returns true) and Object references are passed by value (so effectively, it seems as though objects are being passed by reference). So the value of reference of iArr is passed to the method incr(int[] i); This method changes the actual value of the int element at 0.
Correct response: The code will print i = 1 iArr[0] = 2;
Category: Creating and Using Arrays: Very Easy

Question: 89
What will be the output when the following program is run?

package exceptions;
public class TestClass{
    public static void main(String[] args) {
        try{
            hello();
        }
        catch(MyException me){
            System.out.println(me);
        }
    }
    
    static void hello() throws MyException{
        int[] dear = new int[7];
        dear[0] = 747;
        foo();
    }
    
    static void foo() throws MyException{
        throw new MyException("Exception from foo");
    }
}

class MyException extends Exception {
    public MyException(String msg){
        super(msg);
    }
}
(Assume that line numbers printed in the messages given below are correct.)
1. Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10     at exceptions.TestClass.doTest(TestClass.java:24)     at exceptions.TestClass.main(TestClass.java:14)
2. Error in thread "main" java.lang.ArrayIndexOutOfBoundsException
3. exceptions.MyException: Exception from foo
4. exceptions.MyException: Exception from foo     at exceptions.TestClass.foo(TestClass.java:29)     at exceptions.TestClass.hello(TestClass.java:25)     at exceptions.TestClass.main(TestClass.java:14)

Answer:
Note that there are a few questions in the exam that test your knowledge about how exception messages are printed.  When you use System.out.println(exception), a stack trace is not printed. Just the name of the exception class and the message is printed. When you use exception.printStackTrace(), a complete chain of the names of the methods called, along with the line numbers, is printed from the point where the exception was thrown and up to the point where the exception was caught and printStackTrace() was called.
1. You are creating an array of length 7. Since array numbering starts with 0, the first element would be array[0]. So ArrayIndexOutOfBoundsException will NOT be thrown.
2. java.lang.ArrayIndexOutOfBoundsException extends java.lang.RuntimeException, which in turn extends java.lang.Exception. Therefore, ArrayIndexOutOfBoundsException is an Exception and not an Error.
4. me.printStackTrace() would have produced this output.
Correct response: 3
Category: Handling Exceptions: Tough

Question: 90
What would be the result of attempting to compile and run the following code?

// Filename: TestClass.java
public class TestClass{
   public static void main(String args[]){
      B c = new C();
      System.out.println(c.max(10, 20));
   }
}
class A{
   int max(int x, int y)  { if (x>y) return x; else return y; }
}
class B extends A{
  int max(int x, int y)  {  return 2 * super.max(x, y) ; }
}
class C extends B{
  int max(int x, int y)  {  return super.max( 2*x, 2*y); }
}

Answer:
When the program is run, the main() method will call the max() method in C with parameters 10 and 20 because the actual object referenced by 'c' is of class C. This method will call the max() method in B with the parameters 20 and 40. The max() method in B will in turn call the max() method in A with the parameters 20 and 40. The max() method in A will return 40 to the max() method in B. The max() method in B will return 80 to the max() method in C. And finally the max() of C will return 80 in main() which will be printed out.
Correct response: The code will compile without errors and will print 80 when run.
Category:  Working with Java Data Types - Variables and Objects: Easy