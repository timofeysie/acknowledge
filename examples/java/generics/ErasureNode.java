//package generics;

//import generics.Node;
/* <Integer> dissappears after type erasure.
// A.G.L.B.T.T.D
* After type erasure, the method signatures do not not match. 
* The Node method becomes setData(Object) and the MyNode method
* becomes setData(Integer). Therefore, the MyNode setData method
* does not override the Node setData method.
*/
public class ErasureNode extends Node<Integer> 
{

    public ErasureNode(Integer data) { super(data); }

	/* Bridge method generated by the compiler.
	* It delegates to the original setData method.
    public void setData(Object data) 
    {
        setData((Integer) data);
    }*/

    public void setData(Integer data) 
    {
        System.out.println("ErasureNode.setData");
        super.setData(data);
    }

    public static void main(String[] args) 
    {
    	ErasureNode en = new ErasureNode(5);
		Node n = (ErasureNode)en;         // A raw type - compiler throws an unchecked warning
		n.setData("Hello");
		Integer x = (String)en.data; // Causes a ClassCastException to be thrown.

		// After type erasure, this code becomes:
		ErasureNode mn = new ErasureNode(5);
		Node nn = (ErasureNode)mn;         // A raw type - compiler throws an unchecked warning
		nn.setData("Hello"); // causes the method setData(Object) to be 
		// executed on the object of class MyNode. (The MyNode class 
		// inherited setData(Object) from Node.)
		// In the body of setData(Object), the data field of the object
		// referenced by n is assigned to a String.
		// The data field of that same object, referenced via mn,
		// can be accessed and is expected to be an integer
		// (since mn is a MyNode which is a Node<Integer>.
		// Trying to assign a String to an Integer causes a ClassCastException from a cast inserted at the assignment by a Java compiler.
		x = (String)mn.data; // Causes a ClassCastException to be thrown.

    }

}